// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: auth.proto

#ifndef PROTOBUF_auth_2eproto__INCLUDED
#define PROTOBUF_auth_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_auth_2eproto();
void protobuf_AssignDesc_auth_2eproto();
void protobuf_ShutdownFile_auth_2eproto();

class AuthenticateWithKeyMessage;
class AuthenticateWithDetailsMessage;
class AuthenticateWithTokenMessage;
class AuthenticateResultMessage;
class AuthenticateUserGroupMessage;
class AuthenticateValidateTicketMessage;
class AuthenticateValidateTicketResultMessage;
class AuthenticateKickUserMessage;
class AuthenticateExternalStatusMessage;
class AuthenticateRegisterServerMessage;
class AuthenticateRegisterServerResultMessage;

// ===================================================================

class AuthenticateWithKeyMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateWithKeyMessage();
  virtual ~AuthenticateWithKeyMessage();

  AuthenticateWithKeyMessage(const AuthenticateWithKeyMessage& from);

  inline AuthenticateWithKeyMessage& operator=(const AuthenticateWithKeyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateWithKeyMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateWithKeyMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateWithKeyMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateWithKeyMessage* New() const { return New(NULL); }

  AuthenticateWithKeyMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateWithKeyMessage& from);
  void MergeFrom(const AuthenticateWithKeyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateWithKeyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string licenseKey = 1;
  inline bool has_licensekey() const;
  inline void clear_licensekey();
  static const int kLicenseKeyFieldNumber = 1;
  inline const ::std::string& licensekey() const;
  inline void set_licensekey(const ::std::string& value);
  inline void set_licensekey(const char* value);
  inline void set_licensekey(const char* value, size_t size);
  inline ::std::string* mutable_licensekey();
  inline ::std::string* release_licensekey();
  inline void set_allocated_licensekey(::std::string* licensekey);

  // @@protoc_insertion_point(class_scope:AuthenticateWithKeyMessage)
 private:
  inline void set_has_licensekey();
  inline void clear_has_licensekey();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr licensekey_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateWithKeyMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateWithDetailsMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateWithDetailsMessage();
  virtual ~AuthenticateWithDetailsMessage();

  AuthenticateWithDetailsMessage(const AuthenticateWithDetailsMessage& from);

  inline AuthenticateWithDetailsMessage& operator=(const AuthenticateWithDetailsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateWithDetailsMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateWithDetailsMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateWithDetailsMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateWithDetailsMessage* New() const { return New(NULL); }

  AuthenticateWithDetailsMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateWithDetailsMessage& from);
  void MergeFrom(const AuthenticateWithDetailsMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateWithDetailsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:AuthenticateWithDetailsMessage)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateWithDetailsMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateWithTokenMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateWithTokenMessage();
  virtual ~AuthenticateWithTokenMessage();

  AuthenticateWithTokenMessage(const AuthenticateWithTokenMessage& from);

  inline AuthenticateWithTokenMessage& operator=(const AuthenticateWithTokenMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateWithTokenMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateWithTokenMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateWithTokenMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateWithTokenMessage* New() const { return New(NULL); }

  AuthenticateWithTokenMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateWithTokenMessage& from);
  void MergeFrom(const AuthenticateWithTokenMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateWithTokenMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:AuthenticateWithTokenMessage)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateWithTokenMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateResultMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateResultMessage();
  virtual ~AuthenticateResultMessage();

  AuthenticateResultMessage(const AuthenticateResultMessage& from);

  inline AuthenticateResultMessage& operator=(const AuthenticateResultMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateResultMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateResultMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateResultMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateResultMessage* New() const { return New(NULL); }

  AuthenticateResultMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateResultMessage& from);
  void MergeFrom(const AuthenticateResultMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateResultMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required fixed64 npid = 2;
  inline bool has_npid() const;
  inline void clear_npid();
  static const int kNpidFieldNumber = 2;
  inline ::google::protobuf::uint64 npid() const;
  inline void set_npid(::google::protobuf::uint64 value);

  // required bytes sessionToken = 3;
  inline bool has_sessiontoken() const;
  inline void clear_sessiontoken();
  static const int kSessionTokenFieldNumber = 3;
  inline const ::std::string& sessiontoken() const;
  inline void set_sessiontoken(const ::std::string& value);
  inline void set_sessiontoken(const char* value);
  inline void set_sessiontoken(const void* value, size_t size);
  inline ::std::string* mutable_sessiontoken();
  inline ::std::string* release_sessiontoken();
  inline void set_allocated_sessiontoken(::std::string* sessiontoken);

  // @@protoc_insertion_point(class_scope:AuthenticateResultMessage)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_npid();
  inline void clear_has_npid();
  inline void set_has_sessiontoken();
  inline void clear_has_sessiontoken();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 npid_;
  ::google::protobuf::internal::ArenaStringPtr sessiontoken_;
  ::google::protobuf::int32 result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateResultMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateUserGroupMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateUserGroupMessage();
  virtual ~AuthenticateUserGroupMessage();

  AuthenticateUserGroupMessage(const AuthenticateUserGroupMessage& from);

  inline AuthenticateUserGroupMessage& operator=(const AuthenticateUserGroupMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateUserGroupMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateUserGroupMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateUserGroupMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateUserGroupMessage* New() const { return New(NULL); }

  AuthenticateUserGroupMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateUserGroupMessage& from);
  void MergeFrom(const AuthenticateUserGroupMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateUserGroupMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 groupID = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 1;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AuthenticateUserGroupMessage)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 groupid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateUserGroupMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateValidateTicketMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateValidateTicketMessage();
  virtual ~AuthenticateValidateTicketMessage();

  AuthenticateValidateTicketMessage(const AuthenticateValidateTicketMessage& from);

  inline AuthenticateValidateTicketMessage& operator=(const AuthenticateValidateTicketMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateValidateTicketMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateValidateTicketMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateValidateTicketMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateValidateTicketMessage* New() const { return New(NULL); }

  AuthenticateValidateTicketMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateValidateTicketMessage& from);
  void MergeFrom(const AuthenticateValidateTicketMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateValidateTicketMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 clientIP = 1;
  inline bool has_clientip() const;
  inline void clear_clientip();
  static const int kClientIPFieldNumber = 1;
  inline ::google::protobuf::uint32 clientip() const;
  inline void set_clientip(::google::protobuf::uint32 value);

  // required fixed64 npid = 2;
  inline bool has_npid() const;
  inline void clear_npid();
  static const int kNpidFieldNumber = 2;
  inline ::google::protobuf::uint64 npid() const;
  inline void set_npid(::google::protobuf::uint64 value);

  // required bytes ticket = 3;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 3;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const void* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  inline void set_allocated_ticket(::std::string* ticket);

  // @@protoc_insertion_point(class_scope:AuthenticateValidateTicketMessage)
 private:
  inline void set_has_clientip();
  inline void clear_has_clientip();
  inline void set_has_npid();
  inline void clear_has_npid();
  inline void set_has_ticket();
  inline void clear_has_ticket();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 npid_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::google::protobuf::uint32 clientip_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateValidateTicketMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateValidateTicketResultMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateValidateTicketResultMessage();
  virtual ~AuthenticateValidateTicketResultMessage();

  AuthenticateValidateTicketResultMessage(const AuthenticateValidateTicketResultMessage& from);

  inline AuthenticateValidateTicketResultMessage& operator=(const AuthenticateValidateTicketResultMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateValidateTicketResultMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateValidateTicketResultMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateValidateTicketResultMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateValidateTicketResultMessage* New() const { return New(NULL); }

  AuthenticateValidateTicketResultMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateValidateTicketResultMessage& from);
  void MergeFrom(const AuthenticateValidateTicketResultMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateValidateTicketResultMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required fixed64 npid = 2;
  inline bool has_npid() const;
  inline void clear_npid();
  static const int kNpidFieldNumber = 2;
  inline ::google::protobuf::uint64 npid() const;
  inline void set_npid(::google::protobuf::uint64 value);

  // required int32 groupID = 3;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 3;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AuthenticateValidateTicketResultMessage)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_npid();
  inline void clear_has_npid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 npid_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 groupid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateValidateTicketResultMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateKickUserMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateKickUserMessage();
  virtual ~AuthenticateKickUserMessage();

  AuthenticateKickUserMessage(const AuthenticateKickUserMessage& from);

  inline AuthenticateKickUserMessage& operator=(const AuthenticateKickUserMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateKickUserMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateKickUserMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateKickUserMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateKickUserMessage* New() const { return New(NULL); }

  AuthenticateKickUserMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateKickUserMessage& from);
  void MergeFrom(const AuthenticateKickUserMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateKickUserMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 npid = 1;
  inline bool has_npid() const;
  inline void clear_npid();
  static const int kNpidFieldNumber = 1;
  inline ::google::protobuf::uint64 npid() const;
  inline void set_npid(::google::protobuf::uint64 value);

  // required int32 reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::google::protobuf::int32 reason() const;
  inline void set_reason(::google::protobuf::int32 value);

  // required string reasonString = 3;
  inline bool has_reasonstring() const;
  inline void clear_reasonstring();
  static const int kReasonStringFieldNumber = 3;
  inline const ::std::string& reasonstring() const;
  inline void set_reasonstring(const ::std::string& value);
  inline void set_reasonstring(const char* value);
  inline void set_reasonstring(const char* value, size_t size);
  inline ::std::string* mutable_reasonstring();
  inline ::std::string* release_reasonstring();
  inline void set_allocated_reasonstring(::std::string* reasonstring);

  // @@protoc_insertion_point(class_scope:AuthenticateKickUserMessage)
 private:
  inline void set_has_npid();
  inline void clear_has_npid();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_reasonstring();
  inline void clear_has_reasonstring();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 npid_;
  ::google::protobuf::internal::ArenaStringPtr reasonstring_;
  ::google::protobuf::int32 reason_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateKickUserMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateExternalStatusMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateExternalStatusMessage();
  virtual ~AuthenticateExternalStatusMessage();

  AuthenticateExternalStatusMessage(const AuthenticateExternalStatusMessage& from);

  inline AuthenticateExternalStatusMessage& operator=(const AuthenticateExternalStatusMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateExternalStatusMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateExternalStatusMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateExternalStatusMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateExternalStatusMessage* New() const { return New(NULL); }

  AuthenticateExternalStatusMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateExternalStatusMessage& from);
  void MergeFrom(const AuthenticateExternalStatusMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateExternalStatusMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AuthenticateExternalStatusMessage)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateExternalStatusMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateRegisterServerMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateRegisterServerMessage();
  virtual ~AuthenticateRegisterServerMessage();

  AuthenticateRegisterServerMessage(const AuthenticateRegisterServerMessage& from);

  inline AuthenticateRegisterServerMessage& operator=(const AuthenticateRegisterServerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateRegisterServerMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateRegisterServerMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateRegisterServerMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateRegisterServerMessage* New() const { return New(NULL); }

  AuthenticateRegisterServerMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateRegisterServerMessage& from);
  void MergeFrom(const AuthenticateRegisterServerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateRegisterServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string configPath = 1;
  inline bool has_configpath() const;
  inline void clear_configpath();
  static const int kConfigPathFieldNumber = 1;
  inline const ::std::string& configpath() const;
  inline void set_configpath(const ::std::string& value);
  inline void set_configpath(const char* value);
  inline void set_configpath(const char* value, size_t size);
  inline ::std::string* mutable_configpath();
  inline ::std::string* release_configpath();
  inline void set_allocated_configpath(::std::string* configpath);

  // @@protoc_insertion_point(class_scope:AuthenticateRegisterServerMessage)
 private:
  inline void set_has_configpath();
  inline void clear_has_configpath();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr configpath_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateRegisterServerMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateRegisterServerResultMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateRegisterServerResultMessage();
  virtual ~AuthenticateRegisterServerResultMessage();

  AuthenticateRegisterServerResultMessage(const AuthenticateRegisterServerResultMessage& from);

  inline AuthenticateRegisterServerResultMessage& operator=(const AuthenticateRegisterServerResultMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateRegisterServerResultMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateRegisterServerResultMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateRegisterServerResultMessage* other);

  // implements Message ----------------------------------------------

  inline AuthenticateRegisterServerResultMessage* New() const { return New(NULL); }

  AuthenticateRegisterServerResultMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateRegisterServerResultMessage& from);
  void MergeFrom(const AuthenticateRegisterServerResultMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateRegisterServerResultMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string licenseKey = 2;
  inline bool has_licensekey() const;
  inline void clear_licensekey();
  static const int kLicenseKeyFieldNumber = 2;
  inline const ::std::string& licensekey() const;
  inline void set_licensekey(const ::std::string& value);
  inline void set_licensekey(const char* value);
  inline void set_licensekey(const char* value, size_t size);
  inline ::std::string* mutable_licensekey();
  inline ::std::string* release_licensekey();
  inline void set_allocated_licensekey(::std::string* licensekey);

  // required int32 serverID = 3;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIDFieldNumber = 3;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AuthenticateRegisterServerResultMessage)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_licensekey();
  inline void clear_has_licensekey();
  inline void set_has_serverid();
  inline void clear_has_serverid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr licensekey_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 serverid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateRegisterServerResultMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// AuthenticateWithKeyMessage

// required string licenseKey = 1;
inline bool AuthenticateWithKeyMessage::has_licensekey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateWithKeyMessage::set_has_licensekey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateWithKeyMessage::clear_has_licensekey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateWithKeyMessage::clear_licensekey() {
  licensekey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_licensekey();
}
inline const ::std::string& AuthenticateWithKeyMessage::licensekey() const {
  // @@protoc_insertion_point(field_get:AuthenticateWithKeyMessage.licenseKey)
  return licensekey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateWithKeyMessage::set_licensekey(const ::std::string& value) {
  set_has_licensekey();
  licensekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateWithKeyMessage.licenseKey)
}
inline void AuthenticateWithKeyMessage::set_licensekey(const char* value) {
  set_has_licensekey();
  licensekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateWithKeyMessage.licenseKey)
}
inline void AuthenticateWithKeyMessage::set_licensekey(const char* value, size_t size) {
  set_has_licensekey();
  licensekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateWithKeyMessage.licenseKey)
}
inline ::std::string* AuthenticateWithKeyMessage::mutable_licensekey() {
  set_has_licensekey();
  // @@protoc_insertion_point(field_mutable:AuthenticateWithKeyMessage.licenseKey)
  return licensekey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateWithKeyMessage::release_licensekey() {
  clear_has_licensekey();
  return licensekey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateWithKeyMessage::set_allocated_licensekey(::std::string* licensekey) {
  if (licensekey != NULL) {
    set_has_licensekey();
  } else {
    clear_has_licensekey();
  }
  licensekey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), licensekey);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateWithKeyMessage.licenseKey)
}

// -------------------------------------------------------------------

// AuthenticateWithDetailsMessage

// required string username = 1;
inline bool AuthenticateWithDetailsMessage::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateWithDetailsMessage::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateWithDetailsMessage::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateWithDetailsMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& AuthenticateWithDetailsMessage::username() const {
  // @@protoc_insertion_point(field_get:AuthenticateWithDetailsMessage.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateWithDetailsMessage::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateWithDetailsMessage.username)
}
inline void AuthenticateWithDetailsMessage::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateWithDetailsMessage.username)
}
inline void AuthenticateWithDetailsMessage::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateWithDetailsMessage.username)
}
inline ::std::string* AuthenticateWithDetailsMessage::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:AuthenticateWithDetailsMessage.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateWithDetailsMessage::release_username() {
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateWithDetailsMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateWithDetailsMessage.username)
}

// required string password = 2;
inline bool AuthenticateWithDetailsMessage::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateWithDetailsMessage::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateWithDetailsMessage::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateWithDetailsMessage::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& AuthenticateWithDetailsMessage::password() const {
  // @@protoc_insertion_point(field_get:AuthenticateWithDetailsMessage.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateWithDetailsMessage::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateWithDetailsMessage.password)
}
inline void AuthenticateWithDetailsMessage::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateWithDetailsMessage.password)
}
inline void AuthenticateWithDetailsMessage::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateWithDetailsMessage.password)
}
inline ::std::string* AuthenticateWithDetailsMessage::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:AuthenticateWithDetailsMessage.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateWithDetailsMessage::release_password() {
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateWithDetailsMessage::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateWithDetailsMessage.password)
}

// -------------------------------------------------------------------

// AuthenticateWithTokenMessage

// required bytes token = 1;
inline bool AuthenticateWithTokenMessage::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateWithTokenMessage::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateWithTokenMessage::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateWithTokenMessage::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& AuthenticateWithTokenMessage::token() const {
  // @@protoc_insertion_point(field_get:AuthenticateWithTokenMessage.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateWithTokenMessage::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateWithTokenMessage.token)
}
inline void AuthenticateWithTokenMessage::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateWithTokenMessage.token)
}
inline void AuthenticateWithTokenMessage::set_token(const void* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateWithTokenMessage.token)
}
inline ::std::string* AuthenticateWithTokenMessage::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:AuthenticateWithTokenMessage.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateWithTokenMessage::release_token() {
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateWithTokenMessage::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateWithTokenMessage.token)
}

// -------------------------------------------------------------------

// AuthenticateResultMessage

// required int32 result = 1;
inline bool AuthenticateResultMessage::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateResultMessage::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateResultMessage::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateResultMessage::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AuthenticateResultMessage::result() const {
  // @@protoc_insertion_point(field_get:AuthenticateResultMessage.result)
  return result_;
}
inline void AuthenticateResultMessage::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateResultMessage.result)
}

// required fixed64 npid = 2;
inline bool AuthenticateResultMessage::has_npid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateResultMessage::set_has_npid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateResultMessage::clear_has_npid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateResultMessage::clear_npid() {
  npid_ = GOOGLE_ULONGLONG(0);
  clear_has_npid();
}
inline ::google::protobuf::uint64 AuthenticateResultMessage::npid() const {
  // @@protoc_insertion_point(field_get:AuthenticateResultMessage.npid)
  return npid_;
}
inline void AuthenticateResultMessage::set_npid(::google::protobuf::uint64 value) {
  set_has_npid();
  npid_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateResultMessage.npid)
}

// required bytes sessionToken = 3;
inline bool AuthenticateResultMessage::has_sessiontoken() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateResultMessage::set_has_sessiontoken() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateResultMessage::clear_has_sessiontoken() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateResultMessage::clear_sessiontoken() {
  sessiontoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessiontoken();
}
inline const ::std::string& AuthenticateResultMessage::sessiontoken() const {
  // @@protoc_insertion_point(field_get:AuthenticateResultMessage.sessionToken)
  return sessiontoken_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateResultMessage::set_sessiontoken(const ::std::string& value) {
  set_has_sessiontoken();
  sessiontoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateResultMessage.sessionToken)
}
inline void AuthenticateResultMessage::set_sessiontoken(const char* value) {
  set_has_sessiontoken();
  sessiontoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateResultMessage.sessionToken)
}
inline void AuthenticateResultMessage::set_sessiontoken(const void* value, size_t size) {
  set_has_sessiontoken();
  sessiontoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateResultMessage.sessionToken)
}
inline ::std::string* AuthenticateResultMessage::mutable_sessiontoken() {
  set_has_sessiontoken();
  // @@protoc_insertion_point(field_mutable:AuthenticateResultMessage.sessionToken)
  return sessiontoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateResultMessage::release_sessiontoken() {
  clear_has_sessiontoken();
  return sessiontoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateResultMessage::set_allocated_sessiontoken(::std::string* sessiontoken) {
  if (sessiontoken != NULL) {
    set_has_sessiontoken();
  } else {
    clear_has_sessiontoken();
  }
  sessiontoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessiontoken);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateResultMessage.sessionToken)
}

// -------------------------------------------------------------------

// AuthenticateUserGroupMessage

// required int32 groupID = 1;
inline bool AuthenticateUserGroupMessage::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateUserGroupMessage::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateUserGroupMessage::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateUserGroupMessage::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 AuthenticateUserGroupMessage::groupid() const {
  // @@protoc_insertion_point(field_get:AuthenticateUserGroupMessage.groupID)
  return groupid_;
}
inline void AuthenticateUserGroupMessage::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateUserGroupMessage.groupID)
}

// -------------------------------------------------------------------

// AuthenticateValidateTicketMessage

// required fixed32 clientIP = 1;
inline bool AuthenticateValidateTicketMessage::has_clientip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateValidateTicketMessage::set_has_clientip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateValidateTicketMessage::clear_has_clientip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateValidateTicketMessage::clear_clientip() {
  clientip_ = 0u;
  clear_has_clientip();
}
inline ::google::protobuf::uint32 AuthenticateValidateTicketMessage::clientip() const {
  // @@protoc_insertion_point(field_get:AuthenticateValidateTicketMessage.clientIP)
  return clientip_;
}
inline void AuthenticateValidateTicketMessage::set_clientip(::google::protobuf::uint32 value) {
  set_has_clientip();
  clientip_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateValidateTicketMessage.clientIP)
}

// required fixed64 npid = 2;
inline bool AuthenticateValidateTicketMessage::has_npid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateValidateTicketMessage::set_has_npid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateValidateTicketMessage::clear_has_npid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateValidateTicketMessage::clear_npid() {
  npid_ = GOOGLE_ULONGLONG(0);
  clear_has_npid();
}
inline ::google::protobuf::uint64 AuthenticateValidateTicketMessage::npid() const {
  // @@protoc_insertion_point(field_get:AuthenticateValidateTicketMessage.npid)
  return npid_;
}
inline void AuthenticateValidateTicketMessage::set_npid(::google::protobuf::uint64 value) {
  set_has_npid();
  npid_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateValidateTicketMessage.npid)
}

// required bytes ticket = 3;
inline bool AuthenticateValidateTicketMessage::has_ticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateValidateTicketMessage::set_has_ticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateValidateTicketMessage::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateValidateTicketMessage::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& AuthenticateValidateTicketMessage::ticket() const {
  // @@protoc_insertion_point(field_get:AuthenticateValidateTicketMessage.ticket)
  return ticket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateValidateTicketMessage::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateValidateTicketMessage.ticket)
}
inline void AuthenticateValidateTicketMessage::set_ticket(const char* value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateValidateTicketMessage.ticket)
}
inline void AuthenticateValidateTicketMessage::set_ticket(const void* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateValidateTicketMessage.ticket)
}
inline ::std::string* AuthenticateValidateTicketMessage::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:AuthenticateValidateTicketMessage.ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateValidateTicketMessage::release_ticket() {
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateValidateTicketMessage::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateValidateTicketMessage.ticket)
}

// -------------------------------------------------------------------

// AuthenticateValidateTicketResultMessage

// required int32 result = 1;
inline bool AuthenticateValidateTicketResultMessage::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateValidateTicketResultMessage::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateValidateTicketResultMessage::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateValidateTicketResultMessage::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AuthenticateValidateTicketResultMessage::result() const {
  // @@protoc_insertion_point(field_get:AuthenticateValidateTicketResultMessage.result)
  return result_;
}
inline void AuthenticateValidateTicketResultMessage::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateValidateTicketResultMessage.result)
}

// required fixed64 npid = 2;
inline bool AuthenticateValidateTicketResultMessage::has_npid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateValidateTicketResultMessage::set_has_npid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateValidateTicketResultMessage::clear_has_npid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateValidateTicketResultMessage::clear_npid() {
  npid_ = GOOGLE_ULONGLONG(0);
  clear_has_npid();
}
inline ::google::protobuf::uint64 AuthenticateValidateTicketResultMessage::npid() const {
  // @@protoc_insertion_point(field_get:AuthenticateValidateTicketResultMessage.npid)
  return npid_;
}
inline void AuthenticateValidateTicketResultMessage::set_npid(::google::protobuf::uint64 value) {
  set_has_npid();
  npid_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateValidateTicketResultMessage.npid)
}

// required int32 groupID = 3;
inline bool AuthenticateValidateTicketResultMessage::has_groupid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateValidateTicketResultMessage::set_has_groupid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateValidateTicketResultMessage::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateValidateTicketResultMessage::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 AuthenticateValidateTicketResultMessage::groupid() const {
  // @@protoc_insertion_point(field_get:AuthenticateValidateTicketResultMessage.groupID)
  return groupid_;
}
inline void AuthenticateValidateTicketResultMessage::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateValidateTicketResultMessage.groupID)
}

// -------------------------------------------------------------------

// AuthenticateKickUserMessage

// required fixed64 npid = 1;
inline bool AuthenticateKickUserMessage::has_npid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateKickUserMessage::set_has_npid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateKickUserMessage::clear_has_npid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateKickUserMessage::clear_npid() {
  npid_ = GOOGLE_ULONGLONG(0);
  clear_has_npid();
}
inline ::google::protobuf::uint64 AuthenticateKickUserMessage::npid() const {
  // @@protoc_insertion_point(field_get:AuthenticateKickUserMessage.npid)
  return npid_;
}
inline void AuthenticateKickUserMessage::set_npid(::google::protobuf::uint64 value) {
  set_has_npid();
  npid_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateKickUserMessage.npid)
}

// required int32 reason = 2;
inline bool AuthenticateKickUserMessage::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateKickUserMessage::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateKickUserMessage::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateKickUserMessage::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::google::protobuf::int32 AuthenticateKickUserMessage::reason() const {
  // @@protoc_insertion_point(field_get:AuthenticateKickUserMessage.reason)
  return reason_;
}
inline void AuthenticateKickUserMessage::set_reason(::google::protobuf::int32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateKickUserMessage.reason)
}

// required string reasonString = 3;
inline bool AuthenticateKickUserMessage::has_reasonstring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateKickUserMessage::set_has_reasonstring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateKickUserMessage::clear_has_reasonstring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateKickUserMessage::clear_reasonstring() {
  reasonstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reasonstring();
}
inline const ::std::string& AuthenticateKickUserMessage::reasonstring() const {
  // @@protoc_insertion_point(field_get:AuthenticateKickUserMessage.reasonString)
  return reasonstring_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateKickUserMessage::set_reasonstring(const ::std::string& value) {
  set_has_reasonstring();
  reasonstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateKickUserMessage.reasonString)
}
inline void AuthenticateKickUserMessage::set_reasonstring(const char* value) {
  set_has_reasonstring();
  reasonstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateKickUserMessage.reasonString)
}
inline void AuthenticateKickUserMessage::set_reasonstring(const char* value, size_t size) {
  set_has_reasonstring();
  reasonstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateKickUserMessage.reasonString)
}
inline ::std::string* AuthenticateKickUserMessage::mutable_reasonstring() {
  set_has_reasonstring();
  // @@protoc_insertion_point(field_mutable:AuthenticateKickUserMessage.reasonString)
  return reasonstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateKickUserMessage::release_reasonstring() {
  clear_has_reasonstring();
  return reasonstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateKickUserMessage::set_allocated_reasonstring(::std::string* reasonstring) {
  if (reasonstring != NULL) {
    set_has_reasonstring();
  } else {
    clear_has_reasonstring();
  }
  reasonstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reasonstring);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateKickUserMessage.reasonString)
}

// -------------------------------------------------------------------

// AuthenticateExternalStatusMessage

// required int32 status = 1;
inline bool AuthenticateExternalStatusMessage::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateExternalStatusMessage::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateExternalStatusMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateExternalStatusMessage::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 AuthenticateExternalStatusMessage::status() const {
  // @@protoc_insertion_point(field_get:AuthenticateExternalStatusMessage.status)
  return status_;
}
inline void AuthenticateExternalStatusMessage::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateExternalStatusMessage.status)
}

// -------------------------------------------------------------------

// AuthenticateRegisterServerMessage

// optional string configPath = 1;
inline bool AuthenticateRegisterServerMessage::has_configpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateRegisterServerMessage::set_has_configpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateRegisterServerMessage::clear_has_configpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateRegisterServerMessage::clear_configpath() {
  configpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_configpath();
}
inline const ::std::string& AuthenticateRegisterServerMessage::configpath() const {
  // @@protoc_insertion_point(field_get:AuthenticateRegisterServerMessage.configPath)
  return configpath_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRegisterServerMessage::set_configpath(const ::std::string& value) {
  set_has_configpath();
  configpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateRegisterServerMessage.configPath)
}
inline void AuthenticateRegisterServerMessage::set_configpath(const char* value) {
  set_has_configpath();
  configpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateRegisterServerMessage.configPath)
}
inline void AuthenticateRegisterServerMessage::set_configpath(const char* value, size_t size) {
  set_has_configpath();
  configpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateRegisterServerMessage.configPath)
}
inline ::std::string* AuthenticateRegisterServerMessage::mutable_configpath() {
  set_has_configpath();
  // @@protoc_insertion_point(field_mutable:AuthenticateRegisterServerMessage.configPath)
  return configpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRegisterServerMessage::release_configpath() {
  clear_has_configpath();
  return configpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRegisterServerMessage::set_allocated_configpath(::std::string* configpath) {
  if (configpath != NULL) {
    set_has_configpath();
  } else {
    clear_has_configpath();
  }
  configpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), configpath);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateRegisterServerMessage.configPath)
}

// -------------------------------------------------------------------

// AuthenticateRegisterServerResultMessage

// required int32 result = 1;
inline bool AuthenticateRegisterServerResultMessage::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateRegisterServerResultMessage::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateRegisterServerResultMessage::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateRegisterServerResultMessage::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AuthenticateRegisterServerResultMessage::result() const {
  // @@protoc_insertion_point(field_get:AuthenticateRegisterServerResultMessage.result)
  return result_;
}
inline void AuthenticateRegisterServerResultMessage::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateRegisterServerResultMessage.result)
}

// required string licenseKey = 2;
inline bool AuthenticateRegisterServerResultMessage::has_licensekey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateRegisterServerResultMessage::set_has_licensekey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateRegisterServerResultMessage::clear_has_licensekey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateRegisterServerResultMessage::clear_licensekey() {
  licensekey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_licensekey();
}
inline const ::std::string& AuthenticateRegisterServerResultMessage::licensekey() const {
  // @@protoc_insertion_point(field_get:AuthenticateRegisterServerResultMessage.licenseKey)
  return licensekey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRegisterServerResultMessage::set_licensekey(const ::std::string& value) {
  set_has_licensekey();
  licensekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateRegisterServerResultMessage.licenseKey)
}
inline void AuthenticateRegisterServerResultMessage::set_licensekey(const char* value) {
  set_has_licensekey();
  licensekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateRegisterServerResultMessage.licenseKey)
}
inline void AuthenticateRegisterServerResultMessage::set_licensekey(const char* value, size_t size) {
  set_has_licensekey();
  licensekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateRegisterServerResultMessage.licenseKey)
}
inline ::std::string* AuthenticateRegisterServerResultMessage::mutable_licensekey() {
  set_has_licensekey();
  // @@protoc_insertion_point(field_mutable:AuthenticateRegisterServerResultMessage.licenseKey)
  return licensekey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateRegisterServerResultMessage::release_licensekey() {
  clear_has_licensekey();
  return licensekey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateRegisterServerResultMessage::set_allocated_licensekey(::std::string* licensekey) {
  if (licensekey != NULL) {
    set_has_licensekey();
  } else {
    clear_has_licensekey();
  }
  licensekey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), licensekey);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateRegisterServerResultMessage.licenseKey)
}

// required int32 serverID = 3;
inline bool AuthenticateRegisterServerResultMessage::has_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateRegisterServerResultMessage::set_has_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateRegisterServerResultMessage::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateRegisterServerResultMessage::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 AuthenticateRegisterServerResultMessage::serverid() const {
  // @@protoc_insertion_point(field_get:AuthenticateRegisterServerResultMessage.serverID)
  return serverid_;
}
inline void AuthenticateRegisterServerResultMessage::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateRegisterServerResultMessage.serverID)
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_auth_2eproto__INCLUDED
