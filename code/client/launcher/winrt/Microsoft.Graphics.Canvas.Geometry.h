// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.190111.3

#pragma once

#include "winrt/base.h"


static_assert(winrt::check_version(CPPWINRT_VERSION, "1.0.190111.3"), "Mismatched component and base headers.");
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.Text.2.h"
#include "winrt/impl/Windows.UI.Input.Inking.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.Geometry.2.h"
#include "winrt/Microsoft.Graphics.Canvas.h"

namespace winrt::impl {

template <typename D> Microsoft::Graphics::Canvas::CanvasDevice consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometry<D>::Device() const
{
    Microsoft::Graphics::Canvas::CanvasDevice value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometry)->get_Device(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateFill(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry cachedGeometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateFill(get_abi(geometry), put_abi(cachedGeometry)));
    return cachedGeometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateFill(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float flatteningTolerance) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry cachedGeometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateFillWithFlatteningTolerance(get_abi(geometry), flatteningTolerance, put_abi(cachedGeometry)));
    return cachedGeometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateStroke(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry cachedGeometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateStroke(get_abi(geometry), strokeWidth, put_abi(cachedGeometry)));
    return cachedGeometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateStroke(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry cachedGeometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateStrokeWithStrokeStyle(get_abi(geometry), strokeWidth, get_abi(strokeStyle), put_abi(cachedGeometry)));
    return cachedGeometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateStroke(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, float flatteningTolerance) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry cachedGeometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateStrokeWithStrokeStyleAndFlatteningTolerance(get_abi(geometry), strokeWidth, get_abi(strokeStyle), flatteningTolerance, put_abi(cachedGeometry)));
    return cachedGeometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::CombineWith(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& otherGeometry, Windows::Foundation::Numerics::float3x2 const& otherGeometryTransform, Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const& combine) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->CombineWith(get_abi(otherGeometry), get_abi(otherGeometryTransform), get_abi(combine), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::CombineWith(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& otherGeometry, Windows::Foundation::Numerics::float3x2 const& otherGeometryTransform, Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const& combine, float flatteningTolerance) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->CombineWithUsingFlatteningTolerance(get_abi(otherGeometry), get_abi(otherGeometryTransform), get_abi(combine), flatteningTolerance, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Stroke(float strokeWidth) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Stroke(strokeWidth, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Stroke(float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeWithStrokeStyle(strokeWidth, get_abi(strokeStyle), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Stroke(float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeWithAllOptions(strokeWidth, get_abi(strokeStyle), get_abi(transform), flatteningTolerance, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Outline() const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Outline(put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Outline(Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->OutlineWithTransformAndFlatteningTolerance(get_abi(transform), flatteningTolerance, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Simplify(Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const& simplification) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Simplify(get_abi(simplification), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Simplify(Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const& simplification, Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->SimplifyWithTransformAndFlatteningTolerance(get_abi(simplification), get_abi(transform), flatteningTolerance, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Transform(Windows::Foundation::Numerics::float3x2 const& transform) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Transform(get_abi(transform), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::CompareWith(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& otherGeometry) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation relation{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->CompareWith(get_abi(otherGeometry), put_abi(relation)));
    return relation;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::CompareWith(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& otherGeometry, Windows::Foundation::Numerics::float3x2 const& otherGeometryTransform, float flatteningTolerance) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation relation{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->CompareWithUsingTransformAndFlatteningTolerance(get_abi(otherGeometry), get_abi(otherGeometryTransform), flatteningTolerance, put_abi(relation)));
    return relation;
}

template <typename D> float consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeArea() const
{
    float area{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeArea(&area));
    return area;
}

template <typename D> float consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeArea(Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    float area{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeAreaWithTransformAndFlatteningTolerance(get_abi(transform), flatteningTolerance, &area));
    return area;
}

template <typename D> float consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePathLength() const
{
    float length{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePathLength(&length));
    return length;
}

template <typename D> float consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePathLength(Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    float length{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePathLengthWithTransformAndFlatteningTolerance(get_abi(transform), flatteningTolerance, &length));
    return length;
}

template <typename D> Windows::Foundation::Numerics::float2 consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePointOnPath(float distance) const
{
    Windows::Foundation::Numerics::float2 point{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePointOnPath(distance, put_abi(point)));
    return point;
}

template <typename D> Windows::Foundation::Numerics::float2 consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePointOnPath(float distance, Windows::Foundation::Numerics::float2& tangent) const
{
    Windows::Foundation::Numerics::float2 point{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePointOnPathWithTangent(distance, put_abi(tangent), put_abi(point)));
    return point;
}

template <typename D> Windows::Foundation::Numerics::float2 consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePointOnPath(float length, Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance, Windows::Foundation::Numerics::float2& tangent) const
{
    Windows::Foundation::Numerics::float2 point{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent(length, get_abi(transform), flatteningTolerance, put_abi(tangent), put_abi(point)));
    return point;
}

template <typename D> bool consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::FillContainsPoint(Windows::Foundation::Numerics::float2 const& point) const
{
    bool containsPoint{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->FillContainsPoint(get_abi(point), &containsPoint));
    return containsPoint;
}

template <typename D> bool consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::FillContainsPoint(Windows::Foundation::Numerics::float2 const& point, Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    bool containsPoint{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->FillContainsPointWithTransformAndFlatteningTolerance(get_abi(point), get_abi(transform), flatteningTolerance, &containsPoint));
    return containsPoint;
}

template <typename D> Windows::Foundation::Rect consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeBounds() const
{
    Windows::Foundation::Rect bounds{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeBounds(put_abi(bounds)));
    return bounds;
}

template <typename D> Windows::Foundation::Rect consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeBounds(Windows::Foundation::Numerics::float3x2 const& transform) const
{
    Windows::Foundation::Rect bounds{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeBoundsWithTransform(get_abi(transform), put_abi(bounds)));
    return bounds;
}

template <typename D> Windows::Foundation::Rect consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeStrokeBounds(float strokeWidth) const
{
    Windows::Foundation::Rect bounds{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeStrokeBounds(strokeWidth, put_abi(bounds)));
    return bounds;
}

template <typename D> Windows::Foundation::Rect consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeStrokeBounds(float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
{
    Windows::Foundation::Rect bounds{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeStrokeBoundsWithStrokeStyle(strokeWidth, get_abi(strokeStyle), put_abi(bounds)));
    return bounds;
}

template <typename D> Windows::Foundation::Rect consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeStrokeBounds(float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    Windows::Foundation::Rect bounds{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeStrokeBoundsWithAllOptions(strokeWidth, get_abi(strokeStyle), get_abi(transform), flatteningTolerance, put_abi(bounds)));
    return bounds;
}

template <typename D> bool consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::StrokeContainsPoint(Windows::Foundation::Numerics::float2 const& point, float strokeWidth) const
{
    bool containsPoint{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeContainsPoint(get_abi(point), strokeWidth, &containsPoint));
    return containsPoint;
}

template <typename D> bool consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::StrokeContainsPoint(Windows::Foundation::Numerics::float2 const& point, float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
{
    bool containsPoint{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeContainsPointWithStrokeStyle(get_abi(point), strokeWidth, get_abi(strokeStyle), &containsPoint));
    return containsPoint;
}

template <typename D> bool consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::StrokeContainsPoint(Windows::Foundation::Numerics::float2 const& point, float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    bool containsPoint{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeContainsPointWithAllOptions(get_abi(point), strokeWidth, get_abi(strokeStyle), get_abi(transform), flatteningTolerance, &containsPoint));
    return containsPoint;
}

template <typename D> com_array<Microsoft::Graphics::Canvas::Geometry::CanvasTriangleVertices> consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Tessellate() const
{
    com_array<Microsoft::Graphics::Canvas::Geometry::CanvasTriangleVertices> triangles;
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Tessellate(impl::put_size_abi(triangles), put_abi(triangles)));
    return triangles;
}

template <typename D> com_array<Microsoft::Graphics::Canvas::Geometry::CanvasTriangleVertices> consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Tessellate(Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    com_array<Microsoft::Graphics::Canvas::Geometry::CanvasTriangleVertices> triangles;
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->TessellateWithTransformAndFlatteningTolerance(get_abi(transform), flatteningTolerance, impl::put_size_abi(triangles), put_abi(triangles)));
    return triangles;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::SendPathTo(Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver const& streamReader) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->SendPathTo(get_abi(streamReader)));
}

template <typename D> Microsoft::Graphics::Canvas::CanvasDevice consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Device() const
{
    Microsoft::Graphics::Canvas::CanvasDevice value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->get_Device(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateRectangle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Rect const& rect) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateRectangle(get_abi(resourceCreator), get_abi(rect), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateRectangle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float w, float h) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateRectangleAtCoords(get_abi(resourceCreator), x, y, w, h, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateRoundedRectangle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Rect const& rect, float radiusX, float radiusY) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateRoundedRectangle(get_abi(resourceCreator), get_abi(rect), radiusX, radiusY, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateRoundedRectangle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float w, float h, float radiusX, float radiusY) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateRoundedRectangleAtCoords(get_abi(resourceCreator), x, y, w, h, radiusX, radiusY, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateEllipse(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateEllipse(get_abi(resourceCreator), get_abi(centerPoint), radiusX, radiusY, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateEllipse(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float radiusX, float radiusY) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateEllipseAtCoords(get_abi(resourceCreator), x, y, radiusX, radiusY, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateCircle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Numerics::float2 const& centerPoint, float radius) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateCircle(get_abi(resourceCreator), get_abi(centerPoint), radius, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateCircle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float radius) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateCircleAtCoords(get_abi(resourceCreator), x, y, radius, put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreatePath(Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder const& pathBuilder) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreatePath(get_abi(pathBuilder), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreatePolygon(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<Windows::Foundation::Numerics::float2 const> points) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreatePolygon(get_abi(resourceCreator), points.size(), get_abi(points), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateGroup(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const> geometries) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateGroup(get_abi(resourceCreator), geometries.size(), get_abi(geometries), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateGroup(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const> geometries, Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const& filledRegionDetermination) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateGroupWithFilledRegionDetermination(get_abi(resourceCreator), geometries.size(), get_abi(geometries), get_abi(filledRegionDetermination), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateText(Microsoft::Graphics::Canvas::Text::CanvasTextLayout const& textLayout) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateText(get_abi(textLayout), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateGlyphRun(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Numerics::float2 const& point, Microsoft::Graphics::Canvas::Text::CanvasFontFace const& fontFace, float fontSize, array_view<Microsoft::Graphics::Canvas::Text::CanvasGlyph const> glyphs, bool isSideways, uint32_t bidiLevel, Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const& measuringMode, Microsoft::Graphics::Canvas::Text::CanvasGlyphOrientation const& glyphOrientation) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateGlyphRun(get_abi(resourceCreator), get_abi(point), get_abi(fontFace), fontSize, glyphs.size(), get_abi(glyphs), isSideways, bidiLevel, get_abi(measuringMode), get_abi(glyphOrientation), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateInk(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::iterable<Windows::UI::Input::Inking::InkStroke> const& inkStrokes) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateInk(get_abi(resourceCreator), get_abi(inkStrokes), put_abi(geometry)));
    return geometry;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGeometry consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateInk(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::iterable<Windows::UI::Input::Inking::InkStroke> const& inkStrokes, Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGeometry geometry{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateInkWithTransformAndFlatteningTolerance(get_abi(resourceCreator), get_abi(inkStrokes), get_abi(transform), flatteningTolerance, put_abi(geometry)));
    return geometry;
}

template <typename D> float consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::ComputeFlatteningTolerance(float dpi, float maximumZoomFactor) const
{
    float flatteningTolerance{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->ComputeFlatteningTolerance(dpi, maximumZoomFactor, &flatteningTolerance));
    return flatteningTolerance;
}

template <typename D> float consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::ComputeFlatteningTolerance(float dpi, float maximumZoomFactor, Windows::Foundation::Numerics::float3x2 const& expectedGeometryTransform) const
{
    float flatteningTolerance{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->ComputeFlatteningToleranceWithTransform(dpi, maximumZoomFactor, get_abi(expectedGeometryTransform), &flatteningTolerance));
    return flatteningTolerance;
}

template <typename D> float consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::DefaultFlatteningTolerance() const
{
    float value{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->get_DefaultFlatteningTolerance(&value));
    return value;
}

template <typename D> com_array<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch> consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMesh<D>::Patches() const
{
    com_array<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch> valueElements;
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh)->get_Patches(impl::put_size_abi(valueElements), put_abi(valueElements)));
    return valueElements;
}

template <typename D> Windows::Foundation::Rect consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMesh<D>::GetBounds(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) const
{
    Windows::Foundation::Rect bounds{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh)->GetBounds(get_abi(resourceCreator), put_abi(bounds)));
    return bounds;
}

template <typename D> Windows::Foundation::Rect consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMesh<D>::GetBounds(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Numerics::float3x2 const& transform) const
{
    Windows::Foundation::Rect bounds{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh)->GetBoundsWithTransform(get_abi(resourceCreator), get_abi(transform), put_abi(bounds)));
    return bounds;
}

template <typename D> Microsoft::Graphics::Canvas::CanvasDevice consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMesh<D>::Device() const
{
    Microsoft::Graphics::Canvas::CanvasDevice value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh)->get_Device(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMeshFactory<D>::Create(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const> patchElements) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh canvasGradientMesh{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory)->Create(get_abi(resourceCreator), patchElements.size(), get_abi(patchElements), put_abi(canvasGradientMesh)));
    return canvasGradientMesh;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMeshStatics<D>::CreateCoonsPatch(array_view<Windows::Foundation::Numerics::float2 const> points, array_view<Windows::Foundation::Numerics::float4 const> colors, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const> edges) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch gradientMeshPatch{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics)->CreateCoonsPatch(points.size(), get_abi(points), colors.size(), get_abi(colors), edges.size(), get_abi(edges), put_abi(gradientMeshPatch)));
    return gradientMeshPatch;
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMeshStatics<D>::CreateTensorPatch(array_view<Windows::Foundation::Numerics::float2 const> points, array_view<Windows::Foundation::Numerics::float4 const> colors, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const> edges) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch gradientMeshPatch{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics)->CreateTensorPatch(points.size(), get_abi(points), colors.size(), get_abi(colors), edges.size(), get_abi(edges), put_abi(gradientMeshPatch)));
    return gradientMeshPatch;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::BeginFigure(Windows::Foundation::Numerics::float2 const& startPoint, Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const& figureFill) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->BeginFigureWithFigureFill(get_abi(startPoint), get_abi(figureFill)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::BeginFigure(Windows::Foundation::Numerics::float2 const& startPoint) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->BeginFigure(get_abi(startPoint)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::BeginFigure(float startX, float startY, Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const& figureFill) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->BeginFigureAtCoordsWithFigureFill(startX, startY, get_abi(figureFill)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::BeginFigure(float startX, float startY) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->BeginFigureAtCoords(startX, startY));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddArc(Windows::Foundation::Numerics::float2 const& endPoint, float radiusX, float radiusY, float rotationAngle, Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const& sweepDirection, Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const& arcSize) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddArcToPoint(get_abi(endPoint), radiusX, radiusY, rotationAngle, get_abi(sweepDirection), get_abi(arcSize)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddArc(Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, float startAngle, float sweepAngle) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddArcAroundEllipse(get_abi(centerPoint), radiusX, radiusY, startAngle, sweepAngle));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddCubicBezier(Windows::Foundation::Numerics::float2 const& controlPoint1, Windows::Foundation::Numerics::float2 const& controlPoint2, Windows::Foundation::Numerics::float2 const& endPoint) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddCubicBezier(get_abi(controlPoint1), get_abi(controlPoint2), get_abi(endPoint)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddLine(Windows::Foundation::Numerics::float2 const& endPoint) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddLine(get_abi(endPoint)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddLine(float x, float y) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddLineWithCoords(x, y));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddQuadraticBezier(Windows::Foundation::Numerics::float2 const& controlPoint, Windows::Foundation::Numerics::float2 const& endPoint) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddQuadraticBezier(get_abi(controlPoint), get_abi(endPoint)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::SetFilledRegionDetermination(Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const& filledRegionDetermination) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->SetFilledRegionDetermination(get_abi(filledRegionDetermination)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::SetSegmentOptions(Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const& figureSegmentOptions) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->SetSegmentOptions(get_abi(figureSegmentOptions)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::EndFigure(Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const& figureLoop) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->EndFigure(get_abi(figureLoop)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddGeometry(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddGeometry(get_abi(geometry)));
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilderFactory<D>::Create(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder canvasPathBuilder{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory)->Create(get_abi(resourceCreator), put_abi(canvasPathBuilder)));
    return canvasPathBuilder;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::BeginFigure(Windows::Foundation::Numerics::float2 const& startPoint, Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const& figureFill) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->BeginFigure(get_abi(startPoint), get_abi(figureFill)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::AddArc(Windows::Foundation::Numerics::float2 const& endPoint, float radiusX, float radiusY, float rotationAngle, Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const& sweepDirection, Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const& arcSize) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->AddArc(get_abi(endPoint), radiusX, radiusY, rotationAngle, get_abi(sweepDirection), get_abi(arcSize)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::AddCubicBezier(Windows::Foundation::Numerics::float2 const& controlPoint1, Windows::Foundation::Numerics::float2 const& controlPoint2, Windows::Foundation::Numerics::float2 const& endPoint) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->AddCubicBezier(get_abi(controlPoint1), get_abi(controlPoint2), get_abi(endPoint)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::AddLine(Windows::Foundation::Numerics::float2 const& endPoint) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->AddLine(get_abi(endPoint)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::AddQuadraticBezier(Windows::Foundation::Numerics::float2 const& controlPoint, Windows::Foundation::Numerics::float2 const& endPoint) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->AddQuadraticBezier(get_abi(controlPoint), get_abi(endPoint)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::SetFilledRegionDetermination(Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const& filledRegionDetermination) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->SetFilledRegionDetermination(get_abi(filledRegionDetermination)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::SetSegmentOptions(Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const& figureSegmentOptions) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->SetSegmentOptions(get_abi(figureSegmentOptions)));
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::EndFigure(Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const& figureLoop) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->EndFigure(get_abi(figureLoop)));
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::StartCap() const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle value{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_StartCap(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::StartCap(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_StartCap(get_abi(value)));
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::EndCap() const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle value{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_EndCap(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::EndCap(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_EndCap(get_abi(value)));
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashCap() const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle value{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_DashCap(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashCap(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_DashCap(get_abi(value)));
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::LineJoin() const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin value{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_LineJoin(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::LineJoin(Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_LineJoin(get_abi(value)));
}

template <typename D> float consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::MiterLimit() const
{
    float value{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_MiterLimit(&value));
    return value;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::MiterLimit(float value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_MiterLimit(value));
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashStyle() const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle value{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_DashStyle(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashStyle(Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_DashStyle(get_abi(value)));
}

template <typename D> float consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashOffset() const
{
    float value{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_DashOffset(&value));
    return value;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashOffset(float value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_DashOffset(value));
}

template <typename D> com_array<float> consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::CustomDashStyle() const
{
    com_array<float> valueElements;
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_CustomDashStyle(impl::put_size_abi(valueElements), put_abi(valueElements)));
    return valueElements;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::CustomDashStyle(array_view<float const> valueElements) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_CustomDashStyle(valueElements.size(), get_abi(valueElements)));
}

template <typename D> Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::TransformBehavior() const
{
    Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior value{};
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_TransformBehavior(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::TransformBehavior(Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_TransformBehavior(get_abi(value)));
}

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometry> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometry>
{
    int32_t WINRT_CALL get_Device(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Device, WINRT_WRAP(Microsoft::Graphics::Canvas::CanvasDevice));
            *value = detach_from<Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics>
{
    int32_t WINRT_CALL CreateFill(void* geometry, void** cachedGeometry) noexcept final
    {
        try
        {
            *cachedGeometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateFill, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&);
            *cachedGeometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateFill(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateFillWithFlatteningTolerance(void* geometry, float flatteningTolerance, void** cachedGeometry) noexcept final
    {
        try
        {
            *cachedGeometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateFill, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&, float);
            *cachedGeometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateFill(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateStroke(void* geometry, float strokeWidth, void** cachedGeometry) noexcept final
    {
        try
        {
            *cachedGeometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateStroke, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&, float);
            *cachedGeometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateStroke(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), strokeWidth));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateStrokeWithStrokeStyle(void* geometry, float strokeWidth, void* strokeStyle, void** cachedGeometry) noexcept final
    {
        try
        {
            *cachedGeometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateStroke, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&, float, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const&);
            *cachedGeometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateStroke(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), strokeWidth, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateStrokeWithStrokeStyleAndFlatteningTolerance(void* geometry, float strokeWidth, void* strokeStyle, float flatteningTolerance, void** cachedGeometry) noexcept final
    {
        try
        {
            *cachedGeometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateStroke, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&, float, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const&, float);
            *cachedGeometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateStroke(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), strokeWidth, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry>
{
    int32_t WINRT_CALL CombineWith(void* otherGeometry, Windows::Foundation::Numerics::float3x2 otherGeometryTransform, Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine combine, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CombineWith, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&, Windows::Foundation::Numerics::float3x2 const&, Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CombineWith(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&otherGeometry), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&otherGeometryTransform), *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const*>(&combine)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CombineWithUsingFlatteningTolerance(void* otherGeometry, Windows::Foundation::Numerics::float3x2 otherGeometryTransform, Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine combine, float flatteningTolerance, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CombineWith, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&, Windows::Foundation::Numerics::float3x2 const&, Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const&, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CombineWith(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&otherGeometry), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&otherGeometryTransform), *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const*>(&combine), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Stroke(float strokeWidth, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Stroke, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Stroke(strokeWidth));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL StrokeWithStrokeStyle(float strokeWidth, void* strokeStyle, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Stroke, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), float, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Stroke(strokeWidth, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL StrokeWithAllOptions(float strokeWidth, void* strokeStyle, Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Stroke, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), float, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const&, Windows::Foundation::Numerics::float3x2 const&, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Stroke(strokeWidth, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Outline(void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Outline, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry));
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Outline());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL OutlineWithTransformAndFlatteningTolerance(Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Outline, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Windows::Foundation::Numerics::float3x2 const&, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Outline(*reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Simplify(Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification simplification, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Simplify, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Simplify(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const*>(&simplification)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL SimplifyWithTransformAndFlatteningTolerance(Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification simplification, Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Simplify, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const&, Windows::Foundation::Numerics::float3x2 const&, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Simplify(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const*>(&simplification), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Transform(Windows::Foundation::Numerics::float3x2 transform, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Transform, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Windows::Foundation::Numerics::float3x2 const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Transform(*reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CompareWith(void* otherGeometry, Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation* relation) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CompareWith, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&);
            *relation = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation>(this->shim().CompareWith(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&otherGeometry)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CompareWithUsingTransformAndFlatteningTolerance(void* otherGeometry, Windows::Foundation::Numerics::float3x2 otherGeometryTransform, float flatteningTolerance, Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation* relation) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CompareWith, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&, Windows::Foundation::Numerics::float3x2 const&, float);
            *relation = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation>(this->shim().CompareWith(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&otherGeometry), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&otherGeometryTransform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputeArea(float* area) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputeArea, WINRT_WRAP(float));
            *area = detach_from<float>(this->shim().ComputeArea());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputeAreaWithTransformAndFlatteningTolerance(Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, float* area) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputeArea, WINRT_WRAP(float), Windows::Foundation::Numerics::float3x2 const&, float);
            *area = detach_from<float>(this->shim().ComputeArea(*reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputePathLength(float* length) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputePathLength, WINRT_WRAP(float));
            *length = detach_from<float>(this->shim().ComputePathLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputePathLengthWithTransformAndFlatteningTolerance(Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, float* length) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputePathLength, WINRT_WRAP(float), Windows::Foundation::Numerics::float3x2 const&, float);
            *length = detach_from<float>(this->shim().ComputePathLength(*reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputePointOnPath(float distance, Windows::Foundation::Numerics::float2* point) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputePointOnPath, WINRT_WRAP(Windows::Foundation::Numerics::float2), float);
            *point = detach_from<Windows::Foundation::Numerics::float2>(this->shim().ComputePointOnPath(distance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputePointOnPathWithTangent(float distance, Windows::Foundation::Numerics::float2* tangent, Windows::Foundation::Numerics::float2* point) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputePointOnPath, WINRT_WRAP(Windows::Foundation::Numerics::float2), float, Windows::Foundation::Numerics::float2&);
            *point = detach_from<Windows::Foundation::Numerics::float2>(this->shim().ComputePointOnPath(distance, *reinterpret_cast<Windows::Foundation::Numerics::float2*>(tangent)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent(float length, Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, Windows::Foundation::Numerics::float2* tangent, Windows::Foundation::Numerics::float2* point) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputePointOnPath, WINRT_WRAP(Windows::Foundation::Numerics::float2), float, Windows::Foundation::Numerics::float3x2 const&, float, Windows::Foundation::Numerics::float2&);
            *point = detach_from<Windows::Foundation::Numerics::float2>(this->shim().ComputePointOnPath(length, *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance, *reinterpret_cast<Windows::Foundation::Numerics::float2*>(tangent)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL FillContainsPoint(Windows::Foundation::Numerics::float2 point, bool* containsPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(FillContainsPoint, WINRT_WRAP(bool), Windows::Foundation::Numerics::float2 const&);
            *containsPoint = detach_from<bool>(this->shim().FillContainsPoint(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&point)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL FillContainsPointWithTransformAndFlatteningTolerance(Windows::Foundation::Numerics::float2 point, Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, bool* containsPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(FillContainsPoint, WINRT_WRAP(bool), Windows::Foundation::Numerics::float2 const&, Windows::Foundation::Numerics::float3x2 const&, float);
            *containsPoint = detach_from<bool>(this->shim().FillContainsPoint(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputeBounds(Windows::Foundation::Rect* bounds) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputeBounds, WINRT_WRAP(Windows::Foundation::Rect));
            *bounds = detach_from<Windows::Foundation::Rect>(this->shim().ComputeBounds());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputeBoundsWithTransform(Windows::Foundation::Numerics::float3x2 transform, Windows::Foundation::Rect* bounds) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputeBounds, WINRT_WRAP(Windows::Foundation::Rect), Windows::Foundation::Numerics::float3x2 const&);
            *bounds = detach_from<Windows::Foundation::Rect>(this->shim().ComputeBounds(*reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputeStrokeBounds(float strokeWidth, Windows::Foundation::Rect* bounds) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputeStrokeBounds, WINRT_WRAP(Windows::Foundation::Rect), float);
            *bounds = detach_from<Windows::Foundation::Rect>(this->shim().ComputeStrokeBounds(strokeWidth));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputeStrokeBoundsWithStrokeStyle(float strokeWidth, void* strokeStyle, Windows::Foundation::Rect* bounds) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputeStrokeBounds, WINRT_WRAP(Windows::Foundation::Rect), float, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const&);
            *bounds = detach_from<Windows::Foundation::Rect>(this->shim().ComputeStrokeBounds(strokeWidth, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputeStrokeBoundsWithAllOptions(float strokeWidth, void* strokeStyle, Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, Windows::Foundation::Rect* bounds) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputeStrokeBounds, WINRT_WRAP(Windows::Foundation::Rect), float, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const&, Windows::Foundation::Numerics::float3x2 const&, float);
            *bounds = detach_from<Windows::Foundation::Rect>(this->shim().ComputeStrokeBounds(strokeWidth, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL StrokeContainsPoint(Windows::Foundation::Numerics::float2 point, float strokeWidth, bool* containsPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(StrokeContainsPoint, WINRT_WRAP(bool), Windows::Foundation::Numerics::float2 const&, float);
            *containsPoint = detach_from<bool>(this->shim().StrokeContainsPoint(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&point), strokeWidth));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL StrokeContainsPointWithStrokeStyle(Windows::Foundation::Numerics::float2 point, float strokeWidth, void* strokeStyle, bool* containsPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(StrokeContainsPoint, WINRT_WRAP(bool), Windows::Foundation::Numerics::float2 const&, float, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const&);
            *containsPoint = detach_from<bool>(this->shim().StrokeContainsPoint(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&point), strokeWidth, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL StrokeContainsPointWithAllOptions(Windows::Foundation::Numerics::float2 point, float strokeWidth, void* strokeStyle, Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, bool* containsPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(StrokeContainsPoint, WINRT_WRAP(bool), Windows::Foundation::Numerics::float2 const&, float, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const&, Windows::Foundation::Numerics::float3x2 const&, float);
            *containsPoint = detach_from<bool>(this->shim().StrokeContainsPoint(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&point), strokeWidth, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Tessellate(uint32_t* __trianglesSize, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasTriangleVertices** triangles) noexcept final
    {
        try
        {
            *__trianglesSize = 0;
            *triangles = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Tessellate, WINRT_WRAP(com_array<Microsoft::Graphics::Canvas::Geometry::CanvasTriangleVertices>));
            std::tie(*__trianglesSize, *triangles) = detach_abi(this->shim().Tessellate());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL TessellateWithTransformAndFlatteningTolerance(Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, uint32_t* __trianglesSize, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasTriangleVertices** triangles) noexcept final
    {
        try
        {
            *__trianglesSize = 0;
            *triangles = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Tessellate, WINRT_WRAP(com_array<Microsoft::Graphics::Canvas::Geometry::CanvasTriangleVertices>), Windows::Foundation::Numerics::float3x2 const&, float);
            std::tie(*__trianglesSize, *triangles) = detach_abi(this->shim().Tessellate(*reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL SendPathTo(void* streamReader) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SendPathTo, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver const&);
            this->shim().SendPathTo(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver const*>(&streamReader));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Device(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Device, WINRT_WRAP(Microsoft::Graphics::Canvas::CanvasDevice));
            *value = detach_from<Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>
{
    int32_t WINRT_CALL CreateRectangle(void* resourceCreator, Windows::Foundation::Rect rect, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateRectangle, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, Windows::Foundation::Rect const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateRectangle(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<Windows::Foundation::Rect const*>(&rect)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateRectangleAtCoords(void* resourceCreator, float x, float y, float w, float h, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateRectangle, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, float, float, float, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateRectangle(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), x, y, w, h));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateRoundedRectangle(void* resourceCreator, Windows::Foundation::Rect rect, float radiusX, float radiusY, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateRoundedRectangle, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, Windows::Foundation::Rect const&, float, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateRoundedRectangle(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<Windows::Foundation::Rect const*>(&rect), radiusX, radiusY));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateRoundedRectangleAtCoords(void* resourceCreator, float x, float y, float w, float h, float radiusX, float radiusY, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateRoundedRectangle, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, float, float, float, float, float, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateRoundedRectangle(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), x, y, w, h, radiusX, radiusY));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateEllipse(void* resourceCreator, Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateEllipse, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, Windows::Foundation::Numerics::float2 const&, float, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateEllipse(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateEllipseAtCoords(void* resourceCreator, float x, float y, float radiusX, float radiusY, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateEllipse, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, float, float, float, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateEllipse(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), x, y, radiusX, radiusY));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateCircle(void* resourceCreator, Windows::Foundation::Numerics::float2 centerPoint, float radius, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateCircle, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, Windows::Foundation::Numerics::float2 const&, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateCircle(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateCircleAtCoords(void* resourceCreator, float x, float y, float radius, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateCircle, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, float, float, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateCircle(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), x, y, radius));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreatePath(void* pathBuilder, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreatePath, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreatePath(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder const*>(&pathBuilder)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreatePolygon(void* resourceCreator, uint32_t __pointsSize, Windows::Foundation::Numerics::float2* points, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreatePolygon, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, array_view<Windows::Foundation::Numerics::float2 const>);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreatePolygon(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<Windows::Foundation::Numerics::float2 const>(reinterpret_cast<Windows::Foundation::Numerics::float2 const *>(points), reinterpret_cast<Windows::Foundation::Numerics::float2 const *>(points) + __pointsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateGroup(void* resourceCreator, uint32_t __geometriesSize, void** geometries, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateGroup, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const>);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateGroup(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const>(reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const *>(geometries), reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const *>(geometries) + __geometriesSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateGroupWithFilledRegionDetermination(void* resourceCreator, uint32_t __geometriesSize, void** geometries, Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination filledRegionDetermination, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateGroup, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const>, Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateGroup(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const>(reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const *>(geometries), reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const *>(geometries) + __geometriesSize), *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const*>(&filledRegionDetermination)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateText(void* textLayout, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateText, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::Text::CanvasTextLayout const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateText(*reinterpret_cast<Microsoft::Graphics::Canvas::Text::CanvasTextLayout const*>(&textLayout)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateGlyphRun(void* resourceCreator, Windows::Foundation::Numerics::float2 point, void* fontFace, float fontSize, uint32_t __glyphsSize, struct struct_Microsoft_Graphics_Canvas_Text_CanvasGlyph* glyphs, bool isSideways, uint32_t bidiLevel, Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode measuringMode, Microsoft::Graphics::Canvas::Text::CanvasGlyphOrientation glyphOrientation, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateGlyphRun, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, Windows::Foundation::Numerics::float2 const&, Microsoft::Graphics::Canvas::Text::CanvasFontFace const&, float, array_view<Microsoft::Graphics::Canvas::Text::CanvasGlyph const>, bool, uint32_t, Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const&, Microsoft::Graphics::Canvas::Text::CanvasGlyphOrientation const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateGlyphRun(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<Microsoft::Graphics::Canvas::Text::CanvasFontFace const*>(&fontFace), fontSize, array_view<Microsoft::Graphics::Canvas::Text::CanvasGlyph const>(reinterpret_cast<Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs), reinterpret_cast<Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs) + __glyphsSize), isSideways, bidiLevel, *reinterpret_cast<Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const*>(&measuringMode), *reinterpret_cast<Microsoft::Graphics::Canvas::Text::CanvasGlyphOrientation const*>(&glyphOrientation)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateInk(void* resourceCreator, void* inkStrokes, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInk, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, Windows::Foundation::Collections::IIterable<Windows::UI::Input::Inking::InkStroke> const&);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateInk(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<Windows::Foundation::Collections::IIterable<Windows::UI::Input::Inking::InkStroke> const*>(&inkStrokes)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateInkWithTransformAndFlatteningTolerance(void* resourceCreator, void* inkStrokes, Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, void** geometry) noexcept final
    {
        try
        {
            *geometry = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInk, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, Windows::Foundation::Collections::IIterable<Windows::UI::Input::Inking::InkStroke> const&, Windows::Foundation::Numerics::float3x2 const&, float);
            *geometry = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateInk(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<Windows::Foundation::Collections::IIterable<Windows::UI::Input::Inking::InkStroke> const*>(&inkStrokes), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputeFlatteningTolerance(float dpi, float maximumZoomFactor, float* flatteningTolerance) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputeFlatteningTolerance, WINRT_WRAP(float), float, float);
            *flatteningTolerance = detach_from<float>(this->shim().ComputeFlatteningTolerance(dpi, maximumZoomFactor));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ComputeFlatteningToleranceWithTransform(float dpi, float maximumZoomFactor, Windows::Foundation::Numerics::float3x2 expectedGeometryTransform, float* flatteningTolerance) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ComputeFlatteningTolerance, WINRT_WRAP(float), float, float, Windows::Foundation::Numerics::float3x2 const&);
            *flatteningTolerance = detach_from<float>(this->shim().ComputeFlatteningTolerance(dpi, maximumZoomFactor, *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&expectedGeometryTransform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_DefaultFlatteningTolerance(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DefaultFlatteningTolerance, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().DefaultFlatteningTolerance());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh>
{
    int32_t WINRT_CALL get_Patches(uint32_t* __valueElementsSize, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasGradientMeshPatch** valueElements) noexcept final
    {
        try
        {
            *__valueElementsSize = 0;
            *valueElements = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Patches, WINRT_WRAP(com_array<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch>));
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().Patches());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL GetBounds(void* resourceCreator, Windows::Foundation::Rect* bounds) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(GetBounds, WINRT_WRAP(Windows::Foundation::Rect), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&);
            *bounds = detach_from<Windows::Foundation::Rect>(this->shim().GetBounds(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL GetBoundsWithTransform(void* resourceCreator, Windows::Foundation::Numerics::float3x2 transform, Windows::Foundation::Rect* bounds) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(GetBounds, WINRT_WRAP(Windows::Foundation::Rect), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, Windows::Foundation::Numerics::float3x2 const&);
            *bounds = detach_from<Windows::Foundation::Rect>(this->shim().GetBounds(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<Windows::Foundation::Numerics::float3x2 const*>(&transform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Device(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Device, WINRT_WRAP(Microsoft::Graphics::Canvas::CanvasDevice));
            *value = detach_from<Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory>
{
    int32_t WINRT_CALL Create(void* resourceCreator, uint32_t __patchElementsSize, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasGradientMeshPatch* patchElements, void** canvasGradientMesh) noexcept final
    {
        try
        {
            *canvasGradientMesh = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Create, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const>);
            *canvasGradientMesh = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh>(this->shim().Create(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const>(reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const *>(patchElements), reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const *>(patchElements) + __patchElementsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics>
{
    int32_t WINRT_CALL CreateCoonsPatch(uint32_t __pointsSize, Windows::Foundation::Numerics::float2* points, uint32_t __colorsSize, Windows::Foundation::Numerics::float4* colors, uint32_t __edgesSize, Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge* edges, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasGradientMeshPatch* gradientMeshPatch) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateCoonsPatch, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch), array_view<Windows::Foundation::Numerics::float2 const>, array_view<Windows::Foundation::Numerics::float4 const>, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const>);
            *gradientMeshPatch = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch>(this->shim().CreateCoonsPatch(array_view<Windows::Foundation::Numerics::float2 const>(reinterpret_cast<Windows::Foundation::Numerics::float2 const *>(points), reinterpret_cast<Windows::Foundation::Numerics::float2 const *>(points) + __pointsSize), array_view<Windows::Foundation::Numerics::float4 const>(reinterpret_cast<Windows::Foundation::Numerics::float4 const *>(colors), reinterpret_cast<Windows::Foundation::Numerics::float4 const *>(colors) + __colorsSize), array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const>(reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const *>(edges), reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const *>(edges) + __edgesSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateTensorPatch(uint32_t __pointsSize, Windows::Foundation::Numerics::float2* points, uint32_t __colorsSize, Windows::Foundation::Numerics::float4* colors, uint32_t __edgesSize, Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge* edges, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasGradientMeshPatch* gradientMeshPatch) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateTensorPatch, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch), array_view<Windows::Foundation::Numerics::float2 const>, array_view<Windows::Foundation::Numerics::float4 const>, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const>);
            *gradientMeshPatch = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch>(this->shim().CreateTensorPatch(array_view<Windows::Foundation::Numerics::float2 const>(reinterpret_cast<Windows::Foundation::Numerics::float2 const *>(points), reinterpret_cast<Windows::Foundation::Numerics::float2 const *>(points) + __pointsSize), array_view<Windows::Foundation::Numerics::float4 const>(reinterpret_cast<Windows::Foundation::Numerics::float4 const *>(colors), reinterpret_cast<Windows::Foundation::Numerics::float4 const *>(colors) + __colorsSize), array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const>(reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const *>(edges), reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const *>(edges) + __edgesSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder>
{
    int32_t WINRT_CALL BeginFigureWithFigureFill(Windows::Foundation::Numerics::float2 startPoint, Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill figureFill) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(BeginFigure, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&, Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const&);
            this->shim().BeginFigure(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&startPoint), *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const*>(&figureFill));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL BeginFigure(Windows::Foundation::Numerics::float2 startPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(BeginFigure, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&);
            this->shim().BeginFigure(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&startPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL BeginFigureAtCoordsWithFigureFill(float startX, float startY, Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill figureFill) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(BeginFigure, WINRT_WRAP(void), float, float, Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const&);
            this->shim().BeginFigure(startX, startY, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const*>(&figureFill));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL BeginFigureAtCoords(float startX, float startY) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(BeginFigure, WINRT_WRAP(void), float, float);
            this->shim().BeginFigure(startX, startY);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddArcToPoint(Windows::Foundation::Numerics::float2 endPoint, float radiusX, float radiusY, float rotationAngle, Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection sweepDirection, Microsoft::Graphics::Canvas::Geometry::CanvasArcSize arcSize) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddArc, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&, float, float, float, Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const&, Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const&);
            this->shim().AddArc(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&endPoint), radiusX, radiusY, rotationAngle, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const*>(&sweepDirection), *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const*>(&arcSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddArcAroundEllipse(Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, float startAngle, float sweepAngle) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddArc, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&, float, float, float, float);
            this->shim().AddArc(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, startAngle, sweepAngle);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddCubicBezier(Windows::Foundation::Numerics::float2 controlPoint1, Windows::Foundation::Numerics::float2 controlPoint2, Windows::Foundation::Numerics::float2 endPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddCubicBezier, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&, Windows::Foundation::Numerics::float2 const&, Windows::Foundation::Numerics::float2 const&);
            this->shim().AddCubicBezier(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&controlPoint1), *reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&controlPoint2), *reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddLine(Windows::Foundation::Numerics::float2 endPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddLine, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&);
            this->shim().AddLine(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddLineWithCoords(float x, float y) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddLine, WINRT_WRAP(void), float, float);
            this->shim().AddLine(x, y);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddQuadraticBezier(Windows::Foundation::Numerics::float2 controlPoint, Windows::Foundation::Numerics::float2 endPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddQuadraticBezier, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&, Windows::Foundation::Numerics::float2 const&);
            this->shim().AddQuadraticBezier(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&controlPoint), *reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL SetFilledRegionDetermination(Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination filledRegionDetermination) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SetFilledRegionDetermination, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const&);
            this->shim().SetFilledRegionDetermination(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const*>(&filledRegionDetermination));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL SetSegmentOptions(Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions figureSegmentOptions) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SetSegmentOptions, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const&);
            this->shim().SetSegmentOptions(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const*>(&figureSegmentOptions));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL EndFigure(Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop figureLoop) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(EndFigure, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const&);
            this->shim().EndFigure(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const*>(&figureLoop));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddGeometry(void* geometry) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddGeometry, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const&);
            this->shim().AddGeometry(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory>
{
    int32_t WINRT_CALL Create(void* resourceCreator, void** canvasPathBuilder) noexcept final
    {
        try
        {
            *canvasPathBuilder = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Create, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder), Microsoft::Graphics::Canvas::ICanvasResourceCreator const&);
            *canvasPathBuilder = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder>(this->shim().Create(*reinterpret_cast<Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver>
{
    int32_t WINRT_CALL BeginFigure(Windows::Foundation::Numerics::float2 startPoint, Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill figureFill) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(BeginFigure, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&, Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const&);
            this->shim().BeginFigure(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&startPoint), *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const*>(&figureFill));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddArc(Windows::Foundation::Numerics::float2 endPoint, float radiusX, float radiusY, float rotationAngle, Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection sweepDirection, Microsoft::Graphics::Canvas::Geometry::CanvasArcSize arcSize) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddArc, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&, float, float, float, Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const&, Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const&);
            this->shim().AddArc(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&endPoint), radiusX, radiusY, rotationAngle, *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const*>(&sweepDirection), *reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const*>(&arcSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddCubicBezier(Windows::Foundation::Numerics::float2 controlPoint1, Windows::Foundation::Numerics::float2 controlPoint2, Windows::Foundation::Numerics::float2 endPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddCubicBezier, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&, Windows::Foundation::Numerics::float2 const&, Windows::Foundation::Numerics::float2 const&);
            this->shim().AddCubicBezier(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&controlPoint1), *reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&controlPoint2), *reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddLine(Windows::Foundation::Numerics::float2 endPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddLine, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&);
            this->shim().AddLine(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddQuadraticBezier(Windows::Foundation::Numerics::float2 controlPoint, Windows::Foundation::Numerics::float2 endPoint) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddQuadraticBezier, WINRT_WRAP(void), Windows::Foundation::Numerics::float2 const&, Windows::Foundation::Numerics::float2 const&);
            this->shim().AddQuadraticBezier(*reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&controlPoint), *reinterpret_cast<Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL SetFilledRegionDetermination(Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination filledRegionDetermination) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SetFilledRegionDetermination, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const&);
            this->shim().SetFilledRegionDetermination(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const*>(&filledRegionDetermination));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL SetSegmentOptions(Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions figureSegmentOptions) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SetSegmentOptions, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const&);
            this->shim().SetSegmentOptions(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const*>(&figureSegmentOptions));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL EndFigure(Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop figureLoop) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(EndFigure, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const&);
            this->shim().EndFigure(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const*>(&figureLoop));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle> : produce_base<D, Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle>
{
    int32_t WINRT_CALL get_StartCap(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(StartCap, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle));
            *value = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle>(this->shim().StartCap());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_StartCap(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(StartCap, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const&);
            this->shim().StartCap(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_EndCap(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(EndCap, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle));
            *value = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle>(this->shim().EndCap());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_EndCap(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(EndCap, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const&);
            this->shim().EndCap(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_DashCap(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DashCap, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle));
            *value = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle>(this->shim().DashCap());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_DashCap(Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DashCap, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const&);
            this->shim().DashCap(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_LineJoin(Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LineJoin, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin));
            *value = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin>(this->shim().LineJoin());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_LineJoin(Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LineJoin, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin const&);
            this->shim().LineJoin(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_MiterLimit(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(MiterLimit, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().MiterLimit());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_MiterLimit(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(MiterLimit, WINRT_WRAP(void), float);
            this->shim().MiterLimit(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_DashStyle(Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DashStyle, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle));
            *value = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle>(this->shim().DashStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_DashStyle(Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DashStyle, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle const&);
            this->shim().DashStyle(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_DashOffset(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DashOffset, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().DashOffset());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_DashOffset(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DashOffset, WINRT_WRAP(void), float);
            this->shim().DashOffset(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_CustomDashStyle(uint32_t* __valueElementsSize, float** valueElements) noexcept final
    {
        try
        {
            *__valueElementsSize = 0;
            *valueElements = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CustomDashStyle, WINRT_WRAP(com_array<float>));
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().CustomDashStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_CustomDashStyle(uint32_t __valueElementsSize, float* valueElements) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CustomDashStyle, WINRT_WRAP(void), array_view<float const>);
            this->shim().CustomDashStyle(array_view<float const>(reinterpret_cast<float const *>(valueElements), reinterpret_cast<float const *>(valueElements) + __valueElementsSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_TransformBehavior(Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(TransformBehavior, WINRT_WRAP(Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior));
            *value = detach_from<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior>(this->shim().TransformBehavior());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_TransformBehavior(Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(TransformBehavior, WINRT_WRAP(void), Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior const&);
            this->shim().TransformBehavior(*reinterpret_cast<Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

}

WINRT_EXPORT namespace winrt::Microsoft::Graphics::Canvas::Geometry {

inline Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry CanvasCachedGeometry::CreateFill(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry)
{
    return impl::call_factory<CanvasCachedGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics>([&](auto&& f) { return f.CreateFill(geometry); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry CanvasCachedGeometry::CreateFill(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float flatteningTolerance)
{
    return impl::call_factory<CanvasCachedGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics>([&](auto&& f) { return f.CreateFill(geometry, flatteningTolerance); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry CanvasCachedGeometry::CreateStroke(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth)
{
    return impl::call_factory<CanvasCachedGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics>([&](auto&& f) { return f.CreateStroke(geometry, strokeWidth); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry CanvasCachedGeometry::CreateStroke(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle)
{
    return impl::call_factory<CanvasCachedGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics>([&](auto&& f) { return f.CreateStroke(geometry, strokeWidth, strokeStyle); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry CanvasCachedGeometry::CreateStroke(Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth, Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, float flatteningTolerance)
{
    return impl::call_factory<CanvasCachedGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics>([&](auto&& f) { return f.CreateStroke(geometry, strokeWidth, strokeStyle, flatteningTolerance); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateRectangle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Rect const& rect)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateRectangle(resourceCreator, rect); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateRectangle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float w, float h)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateRectangle(resourceCreator, x, y, w, h); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateRoundedRectangle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Rect const& rect, float radiusX, float radiusY)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateRoundedRectangle(resourceCreator, rect, radiusX, radiusY); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateRoundedRectangle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float w, float h, float radiusX, float radiusY)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateRoundedRectangle(resourceCreator, x, y, w, h, radiusX, radiusY); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateEllipse(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateEllipse(resourceCreator, centerPoint, radiusX, radiusY); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateEllipse(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float radiusX, float radiusY)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateEllipse(resourceCreator, x, y, radiusX, radiusY); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateCircle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Numerics::float2 const& centerPoint, float radius)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateCircle(resourceCreator, centerPoint, radius); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateCircle(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float radius)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateCircle(resourceCreator, x, y, radius); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreatePath(Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder const& pathBuilder)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreatePath(pathBuilder); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreatePolygon(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<Windows::Foundation::Numerics::float2 const> points)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreatePolygon(resourceCreator, points); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateGroup(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const> geometries)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateGroup(resourceCreator, geometries); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateGroup(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const> geometries, Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const& filledRegionDetermination)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateGroup(resourceCreator, geometries, filledRegionDetermination); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateText(Microsoft::Graphics::Canvas::Text::CanvasTextLayout const& textLayout)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateText(textLayout); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateGlyphRun(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, Windows::Foundation::Numerics::float2 const& point, Microsoft::Graphics::Canvas::Text::CanvasFontFace const& fontFace, float fontSize, array_view<Microsoft::Graphics::Canvas::Text::CanvasGlyph const> glyphs, bool isSideways, uint32_t bidiLevel, Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const& measuringMode, Microsoft::Graphics::Canvas::Text::CanvasGlyphOrientation const& glyphOrientation)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateGlyphRun(resourceCreator, point, fontFace, fontSize, glyphs, isSideways, bidiLevel, measuringMode, glyphOrientation); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateInk(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::iterable<Windows::UI::Input::Inking::InkStroke> const& inkStrokes)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateInk(resourceCreator, inkStrokes); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGeometry CanvasGeometry::CreateInk(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::iterable<Windows::UI::Input::Inking::InkStroke> const& inkStrokes, Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.CreateInk(resourceCreator, inkStrokes, transform, flatteningTolerance); });
}

inline float CanvasGeometry::ComputeFlatteningTolerance(float dpi, float maximumZoomFactor)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.ComputeFlatteningTolerance(dpi, maximumZoomFactor); });
}

inline float CanvasGeometry::ComputeFlatteningTolerance(float dpi, float maximumZoomFactor, Windows::Foundation::Numerics::float3x2 const& expectedGeometryTransform)
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.ComputeFlatteningTolerance(dpi, maximumZoomFactor, expectedGeometryTransform); });
}

inline float CanvasGeometry::DefaultFlatteningTolerance()
{
    return impl::call_factory<CanvasGeometry, Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>([&](auto&& f) { return f.DefaultFlatteningTolerance(); });
}

inline CanvasGradientMesh::CanvasGradientMesh(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const> patchElements) :
    CanvasGradientMesh(impl::call_factory<CanvasGradientMesh, Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory>([&](auto&& f) { return f.Create(resourceCreator, patchElements); }))
{}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch CanvasGradientMesh::CreateCoonsPatch(array_view<Windows::Foundation::Numerics::float2 const> points, array_view<Windows::Foundation::Numerics::float4 const> colors, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const> edges)
{
    return impl::call_factory<CanvasGradientMesh, Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics>([&](auto&& f) { return f.CreateCoonsPatch(points, colors, edges); });
}

inline Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch CanvasGradientMesh::CreateTensorPatch(array_view<Windows::Foundation::Numerics::float2 const> points, array_view<Windows::Foundation::Numerics::float4 const> colors, array_view<Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const> edges)
{
    return impl::call_factory<CanvasGradientMesh, Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics>([&](auto&& f) { return f.CreateTensorPatch(points, colors, edges); });
}

inline CanvasPathBuilder::CanvasPathBuilder(Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) :
    CanvasPathBuilder(impl::call_factory<CanvasPathBuilder, Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory>([&](auto&& f) { return f.Create(resourceCreator); }))
{}

inline CanvasStrokeStyle::CanvasStrokeStyle() :
    CanvasStrokeStyle(impl::call_factory<CanvasStrokeStyle>([](auto&& f) { return f.template ActivateInstance<CanvasStrokeStyle>(); }))
{}

}

WINRT_EXPORT namespace std {

template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometry> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometry> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder> {};
template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle> : winrt::impl::hash_base<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle> {};

}
