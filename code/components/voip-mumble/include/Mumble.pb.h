// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mumble.proto

#ifndef PROTOBUF_mumble_2eproto__INCLUDED
#define PROTOBUF_mumble_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace MumbleProto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_mumble_2eproto();
void protobuf_AssignDesc_mumble_2eproto();
void protobuf_ShutdownFile_mumble_2eproto();

class Version;
class UDPTunnel;
class Authenticate;
class Ping;
class Reject;
class ServerSync;
class ChannelRemove;
class ChannelState;
class UserRemove;
class UserState;
class BanList;
class BanList_BanEntry;
class TextMessage;
class PermissionDenied;
class ACL;
class ACL_ChanGroup;
class ACL_ChanACL;
class QueryUsers;
class CryptSetup;
class ContextActionModify;
class ContextAction;
class UserList;
class UserList_User;
class VoiceTarget;
class VoiceTarget_Target;
class PermissionQuery;
class CodecVersion;
class UserStats;
class UserStats_Stats;
class RequestBlob;
class ServerConfig;
class SuggestConfig;

enum Reject_RejectType {
  Reject_RejectType_None = 0,
  Reject_RejectType_WrongVersion = 1,
  Reject_RejectType_InvalidUsername = 2,
  Reject_RejectType_WrongUserPW = 3,
  Reject_RejectType_WrongServerPW = 4,
  Reject_RejectType_UsernameInUse = 5,
  Reject_RejectType_ServerFull = 6,
  Reject_RejectType_NoCertificate = 7,
  Reject_RejectType_AuthenticatorFail = 8
};
bool Reject_RejectType_IsValid(int value);
const Reject_RejectType Reject_RejectType_RejectType_MIN = Reject_RejectType_None;
const Reject_RejectType Reject_RejectType_RejectType_MAX = Reject_RejectType_AuthenticatorFail;
const int Reject_RejectType_RejectType_ARRAYSIZE = Reject_RejectType_RejectType_MAX + 1;

enum PermissionDenied_DenyType {
  PermissionDenied_DenyType_Text = 0,
  PermissionDenied_DenyType_Permission = 1,
  PermissionDenied_DenyType_SuperUser = 2,
  PermissionDenied_DenyType_ChannelName = 3,
  PermissionDenied_DenyType_TextTooLong = 4,
  PermissionDenied_DenyType_H9K = 5,
  PermissionDenied_DenyType_TemporaryChannel = 6,
  PermissionDenied_DenyType_MissingCertificate = 7,
  PermissionDenied_DenyType_UserName = 8,
  PermissionDenied_DenyType_ChannelFull = 9,
  PermissionDenied_DenyType_NestingLimit = 10
};
bool PermissionDenied_DenyType_IsValid(int value);
const PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MIN = PermissionDenied_DenyType_Text;
const PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MAX = PermissionDenied_DenyType_NestingLimit;
const int PermissionDenied_DenyType_DenyType_ARRAYSIZE = PermissionDenied_DenyType_DenyType_MAX + 1;

enum ContextActionModify_Context {
  ContextActionModify_Context_Server = 1,
  ContextActionModify_Context_Channel = 2,
  ContextActionModify_Context_User = 4
};
bool ContextActionModify_Context_IsValid(int value);
const ContextActionModify_Context ContextActionModify_Context_Context_MIN = ContextActionModify_Context_Server;
const ContextActionModify_Context ContextActionModify_Context_Context_MAX = ContextActionModify_Context_User;
const int ContextActionModify_Context_Context_ARRAYSIZE = ContextActionModify_Context_Context_MAX + 1;

enum ContextActionModify_Operation {
  ContextActionModify_Operation_Add = 0,
  ContextActionModify_Operation_Remove = 1
};
bool ContextActionModify_Operation_IsValid(int value);
const ContextActionModify_Operation ContextActionModify_Operation_Operation_MIN = ContextActionModify_Operation_Add;
const ContextActionModify_Operation ContextActionModify_Operation_Operation_MAX = ContextActionModify_Operation_Remove;
const int ContextActionModify_Operation_Operation_ARRAYSIZE = ContextActionModify_Operation_Operation_MAX + 1;

// ===================================================================

class Version : public ::google::protobuf::MessageLite {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Version& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Version* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Version* other);

  // implements Message ----------------------------------------------

  inline Version* New() const { return New(NULL); }

  Version* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Version* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional string release = 2;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 2;
  inline const ::std::string& release() const;
  inline void set_release(const ::std::string& value);
  inline void set_release(const char* value);
  inline void set_release(const char* value, size_t size);
  inline ::std::string* mutable_release();
  inline ::std::string* release_release();
  inline void set_allocated_release(::std::string* release);

  // optional string os = 3;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 3;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string os_version = 4;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 4;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const char* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // @@protoc_insertion_point(class_scope:MumbleProto.Version)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_os_version();
  inline void clear_has_os_version();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr release_;
  ::google::protobuf::internal::ArenaStringPtr os_;
  ::google::protobuf::internal::ArenaStringPtr os_version_;
  ::google::protobuf::uint32 version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static Version* default_instance_;
};
// -------------------------------------------------------------------

class UDPTunnel : public ::google::protobuf::MessageLite {
 public:
  UDPTunnel();
  virtual ~UDPTunnel();

  UDPTunnel(const UDPTunnel& from);

  inline UDPTunnel& operator=(const UDPTunnel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UDPTunnel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UDPTunnel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UDPTunnel* other);

  // implements Message ----------------------------------------------

  inline UDPTunnel* New() const { return New(NULL); }

  UDPTunnel* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UDPTunnel& from);
  void MergeFrom(const UDPTunnel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UDPTunnel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes packet = 1;
  inline bool has_packet() const;
  inline void clear_packet();
  static const int kPacketFieldNumber = 1;
  inline const ::std::string& packet() const;
  inline void set_packet(const ::std::string& value);
  inline void set_packet(const char* value);
  inline void set_packet(const void* value, size_t size);
  inline ::std::string* mutable_packet();
  inline ::std::string* release_packet();
  inline void set_allocated_packet(::std::string* packet);

  // @@protoc_insertion_point(class_scope:MumbleProto.UDPTunnel)
 private:
  inline void set_has_packet();
  inline void clear_has_packet();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr packet_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static UDPTunnel* default_instance_;
};
// -------------------------------------------------------------------

class Authenticate : public ::google::protobuf::MessageLite {
 public:
  Authenticate();
  virtual ~Authenticate();

  Authenticate(const Authenticate& from);

  inline Authenticate& operator=(const Authenticate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Authenticate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Authenticate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Authenticate* other);

  // implements Message ----------------------------------------------

  inline Authenticate* New() const { return New(NULL); }

  Authenticate* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Authenticate& from);
  void MergeFrom(const Authenticate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Authenticate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // repeated string tokens = 3;
  inline int tokens_size() const;
  inline void clear_tokens();
  static const int kTokensFieldNumber = 3;
  inline const ::std::string& tokens(int index) const;
  inline ::std::string* mutable_tokens(int index);
  inline void set_tokens(int index, const ::std::string& value);
  inline void set_tokens(int index, const char* value);
  inline void set_tokens(int index, const char* value, size_t size);
  inline ::std::string* add_tokens();
  inline void add_tokens(const ::std::string& value);
  inline void add_tokens(const char* value);
  inline void add_tokens(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tokens();

  // repeated int32 celt_versions = 4;
  inline int celt_versions_size() const;
  inline void clear_celt_versions();
  static const int kCeltVersionsFieldNumber = 4;
  inline ::google::protobuf::int32 celt_versions(int index) const;
  inline void set_celt_versions(int index, ::google::protobuf::int32 value);
  inline void add_celt_versions(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      celt_versions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_celt_versions();

  // optional bool opus = 5 [default = false];
  inline bool has_opus() const;
  inline void clear_opus();
  static const int kOpusFieldNumber = 5;
  inline bool opus() const;
  inline void set_opus(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.Authenticate)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_opus();
  inline void clear_has_opus();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tokens_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > celt_versions_;
  bool opus_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static Authenticate* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::MessageLite {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Ping& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Ping* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  inline Ping* New() const { return New(NULL); }

  Ping* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 good = 2;
  inline bool has_good() const;
  inline void clear_good();
  static const int kGoodFieldNumber = 2;
  inline ::google::protobuf::uint32 good() const;
  inline void set_good(::google::protobuf::uint32 value);

  // optional uint32 late = 3;
  inline bool has_late() const;
  inline void clear_late();
  static const int kLateFieldNumber = 3;
  inline ::google::protobuf::uint32 late() const;
  inline void set_late(::google::protobuf::uint32 value);

  // optional uint32 lost = 4;
  inline bool has_lost() const;
  inline void clear_lost();
  static const int kLostFieldNumber = 4;
  inline ::google::protobuf::uint32 lost() const;
  inline void set_lost(::google::protobuf::uint32 value);

  // optional uint32 resync = 5;
  inline bool has_resync() const;
  inline void clear_resync();
  static const int kResyncFieldNumber = 5;
  inline ::google::protobuf::uint32 resync() const;
  inline void set_resync(::google::protobuf::uint32 value);

  // optional uint32 udp_packets = 6;
  inline bool has_udp_packets() const;
  inline void clear_udp_packets();
  static const int kUdpPacketsFieldNumber = 6;
  inline ::google::protobuf::uint32 udp_packets() const;
  inline void set_udp_packets(::google::protobuf::uint32 value);

  // optional uint32 tcp_packets = 7;
  inline bool has_tcp_packets() const;
  inline void clear_tcp_packets();
  static const int kTcpPacketsFieldNumber = 7;
  inline ::google::protobuf::uint32 tcp_packets() const;
  inline void set_tcp_packets(::google::protobuf::uint32 value);

  // optional float udp_ping_avg = 8;
  inline bool has_udp_ping_avg() const;
  inline void clear_udp_ping_avg();
  static const int kUdpPingAvgFieldNumber = 8;
  inline float udp_ping_avg() const;
  inline void set_udp_ping_avg(float value);

  // optional float udp_ping_var = 9;
  inline bool has_udp_ping_var() const;
  inline void clear_udp_ping_var();
  static const int kUdpPingVarFieldNumber = 9;
  inline float udp_ping_var() const;
  inline void set_udp_ping_var(float value);

  // optional float tcp_ping_avg = 10;
  inline bool has_tcp_ping_avg() const;
  inline void clear_tcp_ping_avg();
  static const int kTcpPingAvgFieldNumber = 10;
  inline float tcp_ping_avg() const;
  inline void set_tcp_ping_avg(float value);

  // optional float tcp_ping_var = 11;
  inline bool has_tcp_ping_var() const;
  inline void clear_tcp_ping_var();
  static const int kTcpPingVarFieldNumber = 11;
  inline float tcp_ping_var() const;
  inline void set_tcp_ping_var(float value);

  // @@protoc_insertion_point(class_scope:MumbleProto.Ping)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_good();
  inline void clear_has_good();
  inline void set_has_late();
  inline void clear_has_late();
  inline void set_has_lost();
  inline void clear_has_lost();
  inline void set_has_resync();
  inline void clear_has_resync();
  inline void set_has_udp_packets();
  inline void clear_has_udp_packets();
  inline void set_has_tcp_packets();
  inline void clear_has_tcp_packets();
  inline void set_has_udp_ping_avg();
  inline void clear_has_udp_ping_avg();
  inline void set_has_udp_ping_var();
  inline void clear_has_udp_ping_var();
  inline void set_has_tcp_ping_avg();
  inline void clear_has_tcp_ping_avg();
  inline void set_has_tcp_ping_var();
  inline void clear_has_tcp_ping_var();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 good_;
  ::google::protobuf::uint32 late_;
  ::google::protobuf::uint32 lost_;
  ::google::protobuf::uint32 resync_;
  ::google::protobuf::uint32 udp_packets_;
  ::google::protobuf::uint32 tcp_packets_;
  float udp_ping_avg_;
  float udp_ping_var_;
  float tcp_ping_avg_;
  float tcp_ping_var_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Reject : public ::google::protobuf::MessageLite {
 public:
  Reject();
  virtual ~Reject();

  Reject(const Reject& from);

  inline Reject& operator=(const Reject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Reject& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Reject* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Reject* other);

  // implements Message ----------------------------------------------

  inline Reject* New() const { return New(NULL); }

  Reject* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Reject& from);
  void MergeFrom(const Reject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Reject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Reject_RejectType RejectType;
  static const RejectType None = Reject_RejectType_None;
  static const RejectType WrongVersion = Reject_RejectType_WrongVersion;
  static const RejectType InvalidUsername = Reject_RejectType_InvalidUsername;
  static const RejectType WrongUserPW = Reject_RejectType_WrongUserPW;
  static const RejectType WrongServerPW = Reject_RejectType_WrongServerPW;
  static const RejectType UsernameInUse = Reject_RejectType_UsernameInUse;
  static const RejectType ServerFull = Reject_RejectType_ServerFull;
  static const RejectType NoCertificate = Reject_RejectType_NoCertificate;
  static const RejectType AuthenticatorFail = Reject_RejectType_AuthenticatorFail;
  static inline bool RejectType_IsValid(int value) {
    return Reject_RejectType_IsValid(value);
  }
  static const RejectType RejectType_MIN =
    Reject_RejectType_RejectType_MIN;
  static const RejectType RejectType_MAX =
    Reject_RejectType_RejectType_MAX;
  static const int RejectType_ARRAYSIZE =
    Reject_RejectType_RejectType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .MumbleProto.Reject.RejectType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::MumbleProto::Reject_RejectType type() const;
  inline void set_type(::MumbleProto::Reject_RejectType value);

  // optional string reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:MumbleProto.Reject)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static Reject* default_instance_;
};
// -------------------------------------------------------------------

class ServerSync : public ::google::protobuf::MessageLite {
 public:
  ServerSync();
  virtual ~ServerSync();

  ServerSync(const ServerSync& from);

  inline ServerSync& operator=(const ServerSync& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerSync& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerSync* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerSync* other);

  // implements Message ----------------------------------------------

  inline ServerSync* New() const { return New(NULL); }

  ServerSync* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerSync& from);
  void MergeFrom(const ServerSync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerSync* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // optional uint32 max_bandwidth = 2;
  inline bool has_max_bandwidth() const;
  inline void clear_max_bandwidth();
  static const int kMaxBandwidthFieldNumber = 2;
  inline ::google::protobuf::uint32 max_bandwidth() const;
  inline void set_max_bandwidth(::google::protobuf::uint32 value);

  // optional string welcome_text = 3;
  inline bool has_welcome_text() const;
  inline void clear_welcome_text();
  static const int kWelcomeTextFieldNumber = 3;
  inline const ::std::string& welcome_text() const;
  inline void set_welcome_text(const ::std::string& value);
  inline void set_welcome_text(const char* value);
  inline void set_welcome_text(const char* value, size_t size);
  inline ::std::string* mutable_welcome_text();
  inline ::std::string* release_welcome_text();
  inline void set_allocated_welcome_text(::std::string* welcome_text);

  // optional uint64 permissions = 4;
  inline bool has_permissions() const;
  inline void clear_permissions();
  static const int kPermissionsFieldNumber = 4;
  inline ::google::protobuf::uint64 permissions() const;
  inline void set_permissions(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ServerSync)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_max_bandwidth();
  inline void clear_has_max_bandwidth();
  inline void set_has_welcome_text();
  inline void clear_has_welcome_text();
  inline void set_has_permissions();
  inline void clear_has_permissions();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 max_bandwidth_;
  ::google::protobuf::internal::ArenaStringPtr welcome_text_;
  ::google::protobuf::uint64 permissions_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static ServerSync* default_instance_;
};
// -------------------------------------------------------------------

class ChannelRemove : public ::google::protobuf::MessageLite {
 public:
  ChannelRemove();
  virtual ~ChannelRemove();

  ChannelRemove(const ChannelRemove& from);

  inline ChannelRemove& operator=(const ChannelRemove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChannelRemove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChannelRemove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChannelRemove* other);

  // implements Message ----------------------------------------------

  inline ChannelRemove* New() const { return New(NULL); }

  ChannelRemove* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChannelRemove& from);
  void MergeFrom(const ChannelRemove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChannelRemove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ChannelRemove)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 channel_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static ChannelRemove* default_instance_;
};
// -------------------------------------------------------------------

class ChannelState : public ::google::protobuf::MessageLite {
 public:
  ChannelState();
  virtual ~ChannelState();

  ChannelState(const ChannelState& from);

  inline ChannelState& operator=(const ChannelState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChannelState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChannelState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChannelState* other);

  // implements Message ----------------------------------------------

  inline ChannelState* New() const { return New(NULL); }

  ChannelState* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChannelState& from);
  void MergeFrom(const ChannelState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChannelState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline ::google::protobuf::uint32 parent() const;
  inline void set_parent(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated uint32 links = 4;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 4;
  inline ::google::protobuf::uint32 links(int index) const;
  inline void set_links(int index, ::google::protobuf::uint32 value);
  inline void add_links(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      links() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_links();

  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // repeated uint32 links_add = 6;
  inline int links_add_size() const;
  inline void clear_links_add();
  static const int kLinksAddFieldNumber = 6;
  inline ::google::protobuf::uint32 links_add(int index) const;
  inline void set_links_add(int index, ::google::protobuf::uint32 value);
  inline void add_links_add(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      links_add() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_links_add();

  // repeated uint32 links_remove = 7;
  inline int links_remove_size() const;
  inline void clear_links_remove();
  static const int kLinksRemoveFieldNumber = 7;
  inline ::google::protobuf::uint32 links_remove(int index) const;
  inline void set_links_remove(int index, ::google::protobuf::uint32 value);
  inline void add_links_remove(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      links_remove() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_links_remove();

  // optional bool temporary = 8 [default = false];
  inline bool has_temporary() const;
  inline void clear_temporary();
  static const int kTemporaryFieldNumber = 8;
  inline bool temporary() const;
  inline void set_temporary(bool value);

  // optional int32 position = 9 [default = 0];
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 9;
  inline ::google::protobuf::int32 position() const;
  inline void set_position(::google::protobuf::int32 value);

  // optional bytes description_hash = 10;
  inline bool has_description_hash() const;
  inline void clear_description_hash();
  static const int kDescriptionHashFieldNumber = 10;
  inline const ::std::string& description_hash() const;
  inline void set_description_hash(const ::std::string& value);
  inline void set_description_hash(const char* value);
  inline void set_description_hash(const void* value, size_t size);
  inline ::std::string* mutable_description_hash();
  inline ::std::string* release_description_hash();
  inline void set_allocated_description_hash(::std::string* description_hash);

  // @@protoc_insertion_point(class_scope:MumbleProto.ChannelState)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_temporary();
  inline void clear_has_temporary();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_description_hash();
  inline void clear_has_description_hash();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 parent_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_add_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_remove_;
  bool temporary_;
  ::google::protobuf::int32 position_;
  ::google::protobuf::internal::ArenaStringPtr description_hash_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static ChannelState* default_instance_;
};
// -------------------------------------------------------------------

class UserRemove : public ::google::protobuf::MessageLite {
 public:
  UserRemove();
  virtual ~UserRemove();

  UserRemove(const UserRemove& from);

  inline UserRemove& operator=(const UserRemove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserRemove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserRemove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserRemove* other);

  // implements Message ----------------------------------------------

  inline UserRemove* New() const { return New(NULL); }

  UserRemove* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserRemove& from);
  void MergeFrom(const UserRemove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserRemove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // optional uint32 actor = 2;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 2;
  inline ::google::protobuf::uint32 actor() const;
  inline void set_actor(::google::protobuf::uint32 value);

  // optional string reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // optional bool ban = 4;
  inline bool has_ban() const;
  inline void clear_ban();
  static const int kBanFieldNumber = 4;
  inline bool ban() const;
  inline void set_ban(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserRemove)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_actor();
  inline void clear_has_actor();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_ban();
  inline void clear_has_ban();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 actor_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  bool ban_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static UserRemove* default_instance_;
};
// -------------------------------------------------------------------

class UserState : public ::google::protobuf::MessageLite {
 public:
  UserState();
  virtual ~UserState();

  UserState(const UserState& from);

  inline UserState& operator=(const UserState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserState* other);

  // implements Message ----------------------------------------------

  inline UserState* New() const { return New(NULL); }

  UserState* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserState& from);
  void MergeFrom(const UserState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // optional uint32 actor = 2;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 2;
  inline ::google::protobuf::uint32 actor() const;
  inline void set_actor(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 user_id = 4;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional uint32 channel_id = 5;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 5;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional bool mute = 6;
  inline bool has_mute() const;
  inline void clear_mute();
  static const int kMuteFieldNumber = 6;
  inline bool mute() const;
  inline void set_mute(bool value);

  // optional bool deaf = 7;
  inline bool has_deaf() const;
  inline void clear_deaf();
  static const int kDeafFieldNumber = 7;
  inline bool deaf() const;
  inline void set_deaf(bool value);

  // optional bool suppress = 8;
  inline bool has_suppress() const;
  inline void clear_suppress();
  static const int kSuppressFieldNumber = 8;
  inline bool suppress() const;
  inline void set_suppress(bool value);

  // optional bool self_mute = 9;
  inline bool has_self_mute() const;
  inline void clear_self_mute();
  static const int kSelfMuteFieldNumber = 9;
  inline bool self_mute() const;
  inline void set_self_mute(bool value);

  // optional bool self_deaf = 10;
  inline bool has_self_deaf() const;
  inline void clear_self_deaf();
  static const int kSelfDeafFieldNumber = 10;
  inline bool self_deaf() const;
  inline void set_self_deaf(bool value);

  // optional bytes texture = 11;
  inline bool has_texture() const;
  inline void clear_texture();
  static const int kTextureFieldNumber = 11;
  inline const ::std::string& texture() const;
  inline void set_texture(const ::std::string& value);
  inline void set_texture(const char* value);
  inline void set_texture(const void* value, size_t size);
  inline ::std::string* mutable_texture();
  inline ::std::string* release_texture();
  inline void set_allocated_texture(::std::string* texture);

  // optional bytes plugin_context = 12;
  inline bool has_plugin_context() const;
  inline void clear_plugin_context();
  static const int kPluginContextFieldNumber = 12;
  inline const ::std::string& plugin_context() const;
  inline void set_plugin_context(const ::std::string& value);
  inline void set_plugin_context(const char* value);
  inline void set_plugin_context(const void* value, size_t size);
  inline ::std::string* mutable_plugin_context();
  inline ::std::string* release_plugin_context();
  inline void set_allocated_plugin_context(::std::string* plugin_context);

  // optional string plugin_identity = 13;
  inline bool has_plugin_identity() const;
  inline void clear_plugin_identity();
  static const int kPluginIdentityFieldNumber = 13;
  inline const ::std::string& plugin_identity() const;
  inline void set_plugin_identity(const ::std::string& value);
  inline void set_plugin_identity(const char* value);
  inline void set_plugin_identity(const char* value, size_t size);
  inline ::std::string* mutable_plugin_identity();
  inline ::std::string* release_plugin_identity();
  inline void set_allocated_plugin_identity(::std::string* plugin_identity);

  // optional string comment = 14;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 14;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional string hash = 15;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 15;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // optional bytes comment_hash = 16;
  inline bool has_comment_hash() const;
  inline void clear_comment_hash();
  static const int kCommentHashFieldNumber = 16;
  inline const ::std::string& comment_hash() const;
  inline void set_comment_hash(const ::std::string& value);
  inline void set_comment_hash(const char* value);
  inline void set_comment_hash(const void* value, size_t size);
  inline ::std::string* mutable_comment_hash();
  inline ::std::string* release_comment_hash();
  inline void set_allocated_comment_hash(::std::string* comment_hash);

  // optional bytes texture_hash = 17;
  inline bool has_texture_hash() const;
  inline void clear_texture_hash();
  static const int kTextureHashFieldNumber = 17;
  inline const ::std::string& texture_hash() const;
  inline void set_texture_hash(const ::std::string& value);
  inline void set_texture_hash(const char* value);
  inline void set_texture_hash(const void* value, size_t size);
  inline ::std::string* mutable_texture_hash();
  inline ::std::string* release_texture_hash();
  inline void set_allocated_texture_hash(::std::string* texture_hash);

  // optional bool priority_speaker = 18;
  inline bool has_priority_speaker() const;
  inline void clear_priority_speaker();
  static const int kPrioritySpeakerFieldNumber = 18;
  inline bool priority_speaker() const;
  inline void set_priority_speaker(bool value);

  // optional bool recording = 19;
  inline bool has_recording() const;
  inline void clear_recording();
  static const int kRecordingFieldNumber = 19;
  inline bool recording() const;
  inline void set_recording(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserState)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_actor();
  inline void clear_has_actor();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_mute();
  inline void clear_has_mute();
  inline void set_has_deaf();
  inline void clear_has_deaf();
  inline void set_has_suppress();
  inline void clear_has_suppress();
  inline void set_has_self_mute();
  inline void clear_has_self_mute();
  inline void set_has_self_deaf();
  inline void clear_has_self_deaf();
  inline void set_has_texture();
  inline void clear_has_texture();
  inline void set_has_plugin_context();
  inline void clear_has_plugin_context();
  inline void set_has_plugin_identity();
  inline void clear_has_plugin_identity();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_comment_hash();
  inline void clear_has_comment_hash();
  inline void set_has_texture_hash();
  inline void clear_has_texture_hash();
  inline void set_has_priority_speaker();
  inline void clear_has_priority_speaker();
  inline void set_has_recording();
  inline void clear_has_recording();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 actor_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::internal::ArenaStringPtr texture_;
  bool mute_;
  bool deaf_;
  bool suppress_;
  bool self_mute_;
  bool self_deaf_;
  bool priority_speaker_;
  bool recording_;
  ::google::protobuf::internal::ArenaStringPtr plugin_context_;
  ::google::protobuf::internal::ArenaStringPtr plugin_identity_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr comment_hash_;
  ::google::protobuf::internal::ArenaStringPtr texture_hash_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static UserState* default_instance_;
};
// -------------------------------------------------------------------

class BanList_BanEntry : public ::google::protobuf::MessageLite {
 public:
  BanList_BanEntry();
  virtual ~BanList_BanEntry();

  BanList_BanEntry(const BanList_BanEntry& from);

  inline BanList_BanEntry& operator=(const BanList_BanEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BanList_BanEntry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BanList_BanEntry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BanList_BanEntry* other);

  // implements Message ----------------------------------------------

  inline BanList_BanEntry* New() const { return New(NULL); }

  BanList_BanEntry* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BanList_BanEntry& from);
  void MergeFrom(const BanList_BanEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BanList_BanEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // required uint32 mask = 2;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 2;
  inline ::google::protobuf::uint32 mask() const;
  inline void set_mask(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string hash = 4;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 4;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // optional string reason = 5;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 5;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // optional string start = 6;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 6;
  inline const ::std::string& start() const;
  inline void set_start(const ::std::string& value);
  inline void set_start(const char* value);
  inline void set_start(const char* value, size_t size);
  inline ::std::string* mutable_start();
  inline ::std::string* release_start();
  inline void set_allocated_start(::std::string* start);

  // optional uint32 duration = 7;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 7;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.BanList.BanEntry)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint32 mask_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static BanList_BanEntry* default_instance_;
};
// -------------------------------------------------------------------

class BanList : public ::google::protobuf::MessageLite {
 public:
  BanList();
  virtual ~BanList();

  BanList(const BanList& from);

  inline BanList& operator=(const BanList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BanList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BanList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BanList* other);

  // implements Message ----------------------------------------------

  inline BanList* New() const { return New(NULL); }

  BanList* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BanList& from);
  void MergeFrom(const BanList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BanList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BanList_BanEntry BanEntry;

  // accessors -------------------------------------------------------

  // repeated .MumbleProto.BanList.BanEntry bans = 1;
  inline int bans_size() const;
  inline void clear_bans();
  static const int kBansFieldNumber = 1;
  inline const ::MumbleProto::BanList_BanEntry& bans(int index) const;
  inline ::MumbleProto::BanList_BanEntry* mutable_bans(int index);
  inline ::MumbleProto::BanList_BanEntry* add_bans();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
      bans() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
      mutable_bans();

  // optional bool query = 2 [default = false];
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 2;
  inline bool query() const;
  inline void set_query(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.BanList)
 private:
  inline void set_has_query();
  inline void clear_has_query();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry > bans_;
  bool query_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static BanList* default_instance_;
};
// -------------------------------------------------------------------

class TextMessage : public ::google::protobuf::MessageLite {
 public:
  TextMessage();
  virtual ~TextMessage();

  TextMessage(const TextMessage& from);

  inline TextMessage& operator=(const TextMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TextMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextMessage* other);

  // implements Message ----------------------------------------------

  inline TextMessage* New() const { return New(NULL); }

  TextMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextMessage& from);
  void MergeFrom(const TextMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 actor = 1;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 1;
  inline ::google::protobuf::uint32 actor() const;
  inline void set_actor(::google::protobuf::uint32 value);

  // repeated uint32 session = 2;
  inline int session_size() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 2;
  inline ::google::protobuf::uint32 session(int index) const;
  inline void set_session(int index, ::google::protobuf::uint32 value);
  inline void add_session(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session();

  // repeated uint32 channel_id = 3;
  inline int channel_id_size() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 3;
  inline ::google::protobuf::uint32 channel_id(int index) const;
  inline void set_channel_id(int index, ::google::protobuf::uint32 value);
  inline void add_channel_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      channel_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_channel_id();

  // repeated uint32 tree_id = 4;
  inline int tree_id_size() const;
  inline void clear_tree_id();
  static const int kTreeIdFieldNumber = 4;
  inline ::google::protobuf::uint32 tree_id(int index) const;
  inline void set_tree_id(int index, ::google::protobuf::uint32 value);
  inline void add_tree_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tree_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tree_id();

  // required string message = 5;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 5;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:MumbleProto.TextMessage)
 private:
  inline void set_has_actor();
  inline void clear_has_actor();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channel_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tree_id_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 actor_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static TextMessage* default_instance_;
};
// -------------------------------------------------------------------

class PermissionDenied : public ::google::protobuf::MessageLite {
 public:
  PermissionDenied();
  virtual ~PermissionDenied();

  PermissionDenied(const PermissionDenied& from);

  inline PermissionDenied& operator=(const PermissionDenied& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PermissionDenied& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PermissionDenied* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PermissionDenied* other);

  // implements Message ----------------------------------------------

  inline PermissionDenied* New() const { return New(NULL); }

  PermissionDenied* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PermissionDenied& from);
  void MergeFrom(const PermissionDenied& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PermissionDenied* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PermissionDenied_DenyType DenyType;
  static const DenyType Text = PermissionDenied_DenyType_Text;
  static const DenyType Permission = PermissionDenied_DenyType_Permission;
  static const DenyType SuperUser = PermissionDenied_DenyType_SuperUser;
  static const DenyType ChannelName = PermissionDenied_DenyType_ChannelName;
  static const DenyType TextTooLong = PermissionDenied_DenyType_TextTooLong;
  static const DenyType H9K = PermissionDenied_DenyType_H9K;
  static const DenyType TemporaryChannel = PermissionDenied_DenyType_TemporaryChannel;
  static const DenyType MissingCertificate = PermissionDenied_DenyType_MissingCertificate;
  static const DenyType UserName = PermissionDenied_DenyType_UserName;
  static const DenyType ChannelFull = PermissionDenied_DenyType_ChannelFull;
  static const DenyType NestingLimit = PermissionDenied_DenyType_NestingLimit;
  static inline bool DenyType_IsValid(int value) {
    return PermissionDenied_DenyType_IsValid(value);
  }
  static const DenyType DenyType_MIN =
    PermissionDenied_DenyType_DenyType_MIN;
  static const DenyType DenyType_MAX =
    PermissionDenied_DenyType_DenyType_MAX;
  static const int DenyType_ARRAYSIZE =
    PermissionDenied_DenyType_DenyType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 permission = 1;
  inline bool has_permission() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 1;
  inline ::google::protobuf::uint32 permission() const;
  inline void set_permission(::google::protobuf::uint32 value);

  // optional uint32 channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // optional string reason = 4;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 4;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // optional .MumbleProto.PermissionDenied.DenyType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::MumbleProto::PermissionDenied_DenyType type() const;
  inline void set_type(::MumbleProto::PermissionDenied_DenyType value);

  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:MumbleProto.PermissionDenied)
 private:
  inline void set_has_permission();
  inline void clear_has_permission();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 permission_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::uint32 session_;
  int type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static PermissionDenied* default_instance_;
};
// -------------------------------------------------------------------

class ACL_ChanGroup : public ::google::protobuf::MessageLite {
 public:
  ACL_ChanGroup();
  virtual ~ACL_ChanGroup();

  ACL_ChanGroup(const ACL_ChanGroup& from);

  inline ACL_ChanGroup& operator=(const ACL_ChanGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ACL_ChanGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ACL_ChanGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ACL_ChanGroup* other);

  // implements Message ----------------------------------------------

  inline ACL_ChanGroup* New() const { return New(NULL); }

  ACL_ChanGroup* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACL_ChanGroup& from);
  void MergeFrom(const ACL_ChanGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ACL_ChanGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool inherited = 2 [default = true];
  inline bool has_inherited() const;
  inline void clear_inherited();
  static const int kInheritedFieldNumber = 2;
  inline bool inherited() const;
  inline void set_inherited(bool value);

  // optional bool inherit = 3 [default = true];
  inline bool has_inherit() const;
  inline void clear_inherit();
  static const int kInheritFieldNumber = 3;
  inline bool inherit() const;
  inline void set_inherit(bool value);

  // optional bool inheritable = 4 [default = true];
  inline bool has_inheritable() const;
  inline void clear_inheritable();
  static const int kInheritableFieldNumber = 4;
  inline bool inheritable() const;
  inline void set_inheritable(bool value);

  // repeated uint32 add = 5;
  inline int add_size() const;
  inline void clear_add();
  static const int kAddFieldNumber = 5;
  inline ::google::protobuf::uint32 add(int index) const;
  inline void set_add(int index, ::google::protobuf::uint32 value);
  inline void add_add(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      add() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_add();

  // repeated uint32 remove = 6;
  inline int remove_size() const;
  inline void clear_remove();
  static const int kRemoveFieldNumber = 6;
  inline ::google::protobuf::uint32 remove(int index) const;
  inline void set_remove(int index, ::google::protobuf::uint32 value);
  inline void add_remove(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      remove() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_remove();

  // repeated uint32 inherited_members = 7;
  inline int inherited_members_size() const;
  inline void clear_inherited_members();
  static const int kInheritedMembersFieldNumber = 7;
  inline ::google::protobuf::uint32 inherited_members(int index) const;
  inline void set_inherited_members(int index, ::google::protobuf::uint32 value);
  inline void add_inherited_members(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      inherited_members() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_inherited_members();

  // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanGroup)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_inherited();
  inline void clear_has_inherited();
  inline void set_has_inherit();
  inline void clear_has_inherit();
  inline void set_has_inheritable();
  inline void clear_has_inheritable();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > add_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > remove_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > inherited_members_;
  bool inherited_;
  bool inherit_;
  bool inheritable_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static ACL_ChanGroup* default_instance_;
};
// -------------------------------------------------------------------

class ACL_ChanACL : public ::google::protobuf::MessageLite {
 public:
  ACL_ChanACL();
  virtual ~ACL_ChanACL();

  ACL_ChanACL(const ACL_ChanACL& from);

  inline ACL_ChanACL& operator=(const ACL_ChanACL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ACL_ChanACL& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ACL_ChanACL* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ACL_ChanACL* other);

  // implements Message ----------------------------------------------

  inline ACL_ChanACL* New() const { return New(NULL); }

  ACL_ChanACL* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACL_ChanACL& from);
  void MergeFrom(const ACL_ChanACL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ACL_ChanACL* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool apply_here = 1 [default = true];
  inline bool has_apply_here() const;
  inline void clear_apply_here();
  static const int kApplyHereFieldNumber = 1;
  inline bool apply_here() const;
  inline void set_apply_here(bool value);

  // optional bool apply_subs = 2 [default = true];
  inline bool has_apply_subs() const;
  inline void clear_apply_subs();
  static const int kApplySubsFieldNumber = 2;
  inline bool apply_subs() const;
  inline void set_apply_subs(bool value);

  // optional bool inherited = 3 [default = true];
  inline bool has_inherited() const;
  inline void clear_inherited();
  static const int kInheritedFieldNumber = 3;
  inline bool inherited() const;
  inline void set_inherited(bool value);

  // optional uint32 user_id = 4;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional string group = 5;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 5;
  inline const ::std::string& group() const;
  inline void set_group(const ::std::string& value);
  inline void set_group(const char* value);
  inline void set_group(const char* value, size_t size);
  inline ::std::string* mutable_group();
  inline ::std::string* release_group();
  inline void set_allocated_group(::std::string* group);

  // optional uint32 grant = 6;
  inline bool has_grant() const;
  inline void clear_grant();
  static const int kGrantFieldNumber = 6;
  inline ::google::protobuf::uint32 grant() const;
  inline void set_grant(::google::protobuf::uint32 value);

  // optional uint32 deny = 7;
  inline bool has_deny() const;
  inline void clear_deny();
  static const int kDenyFieldNumber = 7;
  inline ::google::protobuf::uint32 deny() const;
  inline void set_deny(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanACL)
 private:
  inline void set_has_apply_here();
  inline void clear_has_apply_here();
  inline void set_has_apply_subs();
  inline void clear_has_apply_subs();
  inline void set_has_inherited();
  inline void clear_has_inherited();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_grant();
  inline void clear_has_grant();
  inline void set_has_deny();
  inline void clear_has_deny();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool apply_here_;
  bool apply_subs_;
  bool inherited_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::internal::ArenaStringPtr group_;
  ::google::protobuf::uint32 grant_;
  ::google::protobuf::uint32 deny_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static ACL_ChanACL* default_instance_;
};
// -------------------------------------------------------------------

class ACL : public ::google::protobuf::MessageLite {
 public:
  ACL();
  virtual ~ACL();

  ACL(const ACL& from);

  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ACL& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ACL* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ACL* other);

  // implements Message ----------------------------------------------

  inline ACL* New() const { return New(NULL); }

  ACL* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ACL* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ACL_ChanGroup ChanGroup;
  typedef ACL_ChanACL ChanACL;

  // accessors -------------------------------------------------------

  // required uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional bool inherit_acls = 2 [default = true];
  inline bool has_inherit_acls() const;
  inline void clear_inherit_acls();
  static const int kInheritAclsFieldNumber = 2;
  inline bool inherit_acls() const;
  inline void set_inherit_acls(bool value);

  // repeated .MumbleProto.ACL.ChanGroup groups = 3;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 3;
  inline const ::MumbleProto::ACL_ChanGroup& groups(int index) const;
  inline ::MumbleProto::ACL_ChanGroup* mutable_groups(int index);
  inline ::MumbleProto::ACL_ChanGroup* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
      mutable_groups();

  // repeated .MumbleProto.ACL.ChanACL acls = 4;
  inline int acls_size() const;
  inline void clear_acls();
  static const int kAclsFieldNumber = 4;
  inline const ::MumbleProto::ACL_ChanACL& acls(int index) const;
  inline ::MumbleProto::ACL_ChanACL* mutable_acls(int index);
  inline ::MumbleProto::ACL_ChanACL* add_acls();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
      acls() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
      mutable_acls();

  // optional bool query = 5 [default = false];
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 5;
  inline bool query() const;
  inline void set_query(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ACL)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_inherit_acls();
  inline void clear_has_inherit_acls();
  inline void set_has_query();
  inline void clear_has_query();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 channel_id_;
  bool inherit_acls_;
  bool query_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup > groups_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL > acls_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static ACL* default_instance_;
};
// -------------------------------------------------------------------

class QueryUsers : public ::google::protobuf::MessageLite {
 public:
  QueryUsers();
  virtual ~QueryUsers();

  QueryUsers(const QueryUsers& from);

  inline QueryUsers& operator=(const QueryUsers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QueryUsers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryUsers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryUsers* other);

  // implements Message ----------------------------------------------

  inline QueryUsers* New() const { return New(NULL); }

  QueryUsers* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryUsers& from);
  void MergeFrom(const QueryUsers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryUsers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 ids = 1;
  inline int ids_size() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 1;
  inline ::google::protobuf::uint32 ids(int index) const;
  inline void set_ids(int index, ::google::protobuf::uint32 value);
  inline void add_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ids();

  // repeated string names = 2;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 2;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // @@protoc_insertion_point(class_scope:MumbleProto.QueryUsers)
 private:

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static QueryUsers* default_instance_;
};
// -------------------------------------------------------------------

class CryptSetup : public ::google::protobuf::MessageLite {
 public:
  CryptSetup();
  virtual ~CryptSetup();

  CryptSetup(const CryptSetup& from);

  inline CryptSetup& operator=(const CryptSetup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CryptSetup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CryptSetup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CryptSetup* other);

  // implements Message ----------------------------------------------

  inline CryptSetup* New() const { return New(NULL); }

  CryptSetup* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CryptSetup& from);
  void MergeFrom(const CryptSetup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CryptSetup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes client_nonce = 2;
  inline bool has_client_nonce() const;
  inline void clear_client_nonce();
  static const int kClientNonceFieldNumber = 2;
  inline const ::std::string& client_nonce() const;
  inline void set_client_nonce(const ::std::string& value);
  inline void set_client_nonce(const char* value);
  inline void set_client_nonce(const void* value, size_t size);
  inline ::std::string* mutable_client_nonce();
  inline ::std::string* release_client_nonce();
  inline void set_allocated_client_nonce(::std::string* client_nonce);

  // optional bytes server_nonce = 3;
  inline bool has_server_nonce() const;
  inline void clear_server_nonce();
  static const int kServerNonceFieldNumber = 3;
  inline const ::std::string& server_nonce() const;
  inline void set_server_nonce(const ::std::string& value);
  inline void set_server_nonce(const char* value);
  inline void set_server_nonce(const void* value, size_t size);
  inline ::std::string* mutable_server_nonce();
  inline ::std::string* release_server_nonce();
  inline void set_allocated_server_nonce(::std::string* server_nonce);

  // @@protoc_insertion_point(class_scope:MumbleProto.CryptSetup)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_client_nonce();
  inline void clear_has_client_nonce();
  inline void set_has_server_nonce();
  inline void clear_has_server_nonce();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr client_nonce_;
  ::google::protobuf::internal::ArenaStringPtr server_nonce_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static CryptSetup* default_instance_;
};
// -------------------------------------------------------------------

class ContextActionModify : public ::google::protobuf::MessageLite {
 public:
  ContextActionModify();
  virtual ~ContextActionModify();

  ContextActionModify(const ContextActionModify& from);

  inline ContextActionModify& operator=(const ContextActionModify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ContextActionModify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ContextActionModify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ContextActionModify* other);

  // implements Message ----------------------------------------------

  inline ContextActionModify* New() const { return New(NULL); }

  ContextActionModify* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ContextActionModify& from);
  void MergeFrom(const ContextActionModify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContextActionModify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ContextActionModify_Context Context;
  static const Context Server = ContextActionModify_Context_Server;
  static const Context Channel = ContextActionModify_Context_Channel;
  static const Context User = ContextActionModify_Context_User;
  static inline bool Context_IsValid(int value) {
    return ContextActionModify_Context_IsValid(value);
  }
  static const Context Context_MIN =
    ContextActionModify_Context_Context_MIN;
  static const Context Context_MAX =
    ContextActionModify_Context_Context_MAX;
  static const int Context_ARRAYSIZE =
    ContextActionModify_Context_Context_ARRAYSIZE;

  typedef ContextActionModify_Operation Operation;
  static const Operation Add = ContextActionModify_Operation_Add;
  static const Operation Remove = ContextActionModify_Operation_Remove;
  static inline bool Operation_IsValid(int value) {
    return ContextActionModify_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    ContextActionModify_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    ContextActionModify_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    ContextActionModify_Operation_Operation_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline const ::std::string& action() const;
  inline void set_action(const ::std::string& value);
  inline void set_action(const char* value);
  inline void set_action(const char* value, size_t size);
  inline ::std::string* mutable_action();
  inline ::std::string* release_action();
  inline void set_allocated_action(::std::string* action);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional uint32 context = 3;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 3;
  inline ::google::protobuf::uint32 context() const;
  inline void set_context(::google::protobuf::uint32 value);

  // optional .MumbleProto.ContextActionModify.Operation operation = 4;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 4;
  inline ::MumbleProto::ContextActionModify_Operation operation() const;
  inline void set_operation(::MumbleProto::ContextActionModify_Operation value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ContextActionModify)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_operation();
  inline void clear_has_operation();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 context_;
  int operation_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static ContextActionModify* default_instance_;
};
// -------------------------------------------------------------------

class ContextAction : public ::google::protobuf::MessageLite {
 public:
  ContextAction();
  virtual ~ContextAction();

  ContextAction(const ContextAction& from);

  inline ContextAction& operator=(const ContextAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ContextAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ContextAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ContextAction* other);

  // implements Message ----------------------------------------------

  inline ContextAction* New() const { return New(NULL); }

  ContextAction* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ContextAction& from);
  void MergeFrom(const ContextAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContextAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // optional uint32 channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // required string action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline const ::std::string& action() const;
  inline void set_action(const ::std::string& value);
  inline void set_action(const char* value);
  inline void set_action(const char* value, size_t size);
  inline ::std::string* mutable_action();
  inline ::std::string* release_action();
  inline void set_allocated_action(::std::string* action);

  // @@protoc_insertion_point(class_scope:MumbleProto.ContextAction)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_action();
  inline void clear_has_action();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static ContextAction* default_instance_;
};
// -------------------------------------------------------------------

class UserList_User : public ::google::protobuf::MessageLite {
 public:
  UserList_User();
  virtual ~UserList_User();

  UserList_User(const UserList_User& from);

  inline UserList_User& operator=(const UserList_User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserList_User& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserList_User* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserList_User* other);

  // implements Message ----------------------------------------------

  inline UserList_User* New() const { return New(NULL); }

  UserList_User* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserList_User& from);
  void MergeFrom(const UserList_User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserList_User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string last_seen = 3;
  inline bool has_last_seen() const;
  inline void clear_last_seen();
  static const int kLastSeenFieldNumber = 3;
  inline const ::std::string& last_seen() const;
  inline void set_last_seen(const ::std::string& value);
  inline void set_last_seen(const char* value);
  inline void set_last_seen(const char* value, size_t size);
  inline ::std::string* mutable_last_seen();
  inline ::std::string* release_last_seen();
  inline void set_allocated_last_seen(::std::string* last_seen);

  // optional uint32 last_channel = 4;
  inline bool has_last_channel() const;
  inline void clear_last_channel();
  static const int kLastChannelFieldNumber = 4;
  inline ::google::protobuf::uint32 last_channel() const;
  inline void set_last_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserList.User)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_last_seen();
  inline void clear_has_last_seen();
  inline void set_has_last_channel();
  inline void clear_has_last_channel();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 last_channel_;
  ::google::protobuf::internal::ArenaStringPtr last_seen_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static UserList_User* default_instance_;
};
// -------------------------------------------------------------------

class UserList : public ::google::protobuf::MessageLite {
 public:
  UserList();
  virtual ~UserList();

  UserList(const UserList& from);

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserList* other);

  // implements Message ----------------------------------------------

  inline UserList* New() const { return New(NULL); }

  UserList* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UserList_User User;

  // accessors -------------------------------------------------------

  // repeated .MumbleProto.UserList.User users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::MumbleProto::UserList_User& users(int index) const;
  inline ::MumbleProto::UserList_User* mutable_users(int index);
  inline ::MumbleProto::UserList_User* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >*
      mutable_users();

  // @@protoc_insertion_point(class_scope:MumbleProto.UserList)
 private:

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User > users_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static UserList* default_instance_;
};
// -------------------------------------------------------------------

class VoiceTarget_Target : public ::google::protobuf::MessageLite {
 public:
  VoiceTarget_Target();
  virtual ~VoiceTarget_Target();

  VoiceTarget_Target(const VoiceTarget_Target& from);

  inline VoiceTarget_Target& operator=(const VoiceTarget_Target& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VoiceTarget_Target& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VoiceTarget_Target* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VoiceTarget_Target* other);

  // implements Message ----------------------------------------------

  inline VoiceTarget_Target* New() const { return New(NULL); }

  VoiceTarget_Target* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VoiceTarget_Target& from);
  void MergeFrom(const VoiceTarget_Target& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoiceTarget_Target* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 session = 1;
  inline int session_size() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session(int index) const;
  inline void set_session(int index, ::google::protobuf::uint32 value);
  inline void add_session(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session();

  // optional uint32 channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional string group = 3;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 3;
  inline const ::std::string& group() const;
  inline void set_group(const ::std::string& value);
  inline void set_group(const char* value);
  inline void set_group(const char* value, size_t size);
  inline ::std::string* mutable_group();
  inline ::std::string* release_group();
  inline void set_allocated_group(::std::string* group);

  // optional bool links = 4 [default = false];
  inline bool has_links() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 4;
  inline bool links() const;
  inline void set_links(bool value);

  // optional bool children = 5 [default = false];
  inline bool has_children() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 5;
  inline bool children() const;
  inline void set_children(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget.Target)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_links();
  inline void clear_has_links();
  inline void set_has_children();
  inline void clear_has_children();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_;
  ::google::protobuf::internal::ArenaStringPtr group_;
  ::google::protobuf::uint32 channel_id_;
  bool links_;
  bool children_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static VoiceTarget_Target* default_instance_;
};
// -------------------------------------------------------------------

class VoiceTarget : public ::google::protobuf::MessageLite {
 public:
  VoiceTarget();
  virtual ~VoiceTarget();

  VoiceTarget(const VoiceTarget& from);

  inline VoiceTarget& operator=(const VoiceTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VoiceTarget& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VoiceTarget* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VoiceTarget* other);

  // implements Message ----------------------------------------------

  inline VoiceTarget* New() const { return New(NULL); }

  VoiceTarget* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VoiceTarget& from);
  void MergeFrom(const VoiceTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoiceTarget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef VoiceTarget_Target Target;

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // repeated .MumbleProto.VoiceTarget.Target targets = 2;
  inline int targets_size() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 2;
  inline const ::MumbleProto::VoiceTarget_Target& targets(int index) const;
  inline ::MumbleProto::VoiceTarget_Target* mutable_targets(int index);
  inline ::MumbleProto::VoiceTarget_Target* add_targets();
  inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
      targets() const;
  inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
      mutable_targets();

  // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target > targets_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static VoiceTarget* default_instance_;
};
// -------------------------------------------------------------------

class PermissionQuery : public ::google::protobuf::MessageLite {
 public:
  PermissionQuery();
  virtual ~PermissionQuery();

  PermissionQuery(const PermissionQuery& from);

  inline PermissionQuery& operator=(const PermissionQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PermissionQuery& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PermissionQuery* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PermissionQuery* other);

  // implements Message ----------------------------------------------

  inline PermissionQuery* New() const { return New(NULL); }

  PermissionQuery* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PermissionQuery& from);
  void MergeFrom(const PermissionQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PermissionQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 permissions = 2;
  inline bool has_permissions() const;
  inline void clear_permissions();
  static const int kPermissionsFieldNumber = 2;
  inline ::google::protobuf::uint32 permissions() const;
  inline void set_permissions(::google::protobuf::uint32 value);

  // optional bool flush = 3 [default = false];
  inline bool has_flush() const;
  inline void clear_flush();
  static const int kFlushFieldNumber = 3;
  inline bool flush() const;
  inline void set_flush(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.PermissionQuery)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_permissions();
  inline void clear_has_permissions();
  inline void set_has_flush();
  inline void clear_has_flush();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 permissions_;
  bool flush_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static PermissionQuery* default_instance_;
};
// -------------------------------------------------------------------

class CodecVersion : public ::google::protobuf::MessageLite {
 public:
  CodecVersion();
  virtual ~CodecVersion();

  CodecVersion(const CodecVersion& from);

  inline CodecVersion& operator=(const CodecVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CodecVersion& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CodecVersion* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CodecVersion* other);

  // implements Message ----------------------------------------------

  inline CodecVersion* New() const { return New(NULL); }

  CodecVersion* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CodecVersion& from);
  void MergeFrom(const CodecVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CodecVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 alpha = 1;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  inline ::google::protobuf::int32 alpha() const;
  inline void set_alpha(::google::protobuf::int32 value);

  // required int32 beta = 2;
  inline bool has_beta() const;
  inline void clear_beta();
  static const int kBetaFieldNumber = 2;
  inline ::google::protobuf::int32 beta() const;
  inline void set_beta(::google::protobuf::int32 value);

  // required bool prefer_alpha = 3 [default = true];
  inline bool has_prefer_alpha() const;
  inline void clear_prefer_alpha();
  static const int kPreferAlphaFieldNumber = 3;
  inline bool prefer_alpha() const;
  inline void set_prefer_alpha(bool value);

  // optional bool opus = 4 [default = false];
  inline bool has_opus() const;
  inline void clear_opus();
  static const int kOpusFieldNumber = 4;
  inline bool opus() const;
  inline void set_opus(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.CodecVersion)
 private:
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_beta();
  inline void clear_has_beta();
  inline void set_has_prefer_alpha();
  inline void clear_has_prefer_alpha();
  inline void set_has_opus();
  inline void clear_has_opus();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 alpha_;
  ::google::protobuf::int32 beta_;
  bool prefer_alpha_;
  bool opus_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static CodecVersion* default_instance_;
};
// -------------------------------------------------------------------

class UserStats_Stats : public ::google::protobuf::MessageLite {
 public:
  UserStats_Stats();
  virtual ~UserStats_Stats();

  UserStats_Stats(const UserStats_Stats& from);

  inline UserStats_Stats& operator=(const UserStats_Stats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserStats_Stats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserStats_Stats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserStats_Stats* other);

  // implements Message ----------------------------------------------

  inline UserStats_Stats* New() const { return New(NULL); }

  UserStats_Stats* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserStats_Stats& from);
  void MergeFrom(const UserStats_Stats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserStats_Stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 good = 1;
  inline bool has_good() const;
  inline void clear_good();
  static const int kGoodFieldNumber = 1;
  inline ::google::protobuf::uint32 good() const;
  inline void set_good(::google::protobuf::uint32 value);

  // optional uint32 late = 2;
  inline bool has_late() const;
  inline void clear_late();
  static const int kLateFieldNumber = 2;
  inline ::google::protobuf::uint32 late() const;
  inline void set_late(::google::protobuf::uint32 value);

  // optional uint32 lost = 3;
  inline bool has_lost() const;
  inline void clear_lost();
  static const int kLostFieldNumber = 3;
  inline ::google::protobuf::uint32 lost() const;
  inline void set_lost(::google::protobuf::uint32 value);

  // optional uint32 resync = 4;
  inline bool has_resync() const;
  inline void clear_resync();
  static const int kResyncFieldNumber = 4;
  inline ::google::protobuf::uint32 resync() const;
  inline void set_resync(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserStats.Stats)
 private:
  inline void set_has_good();
  inline void clear_has_good();
  inline void set_has_late();
  inline void clear_has_late();
  inline void set_has_lost();
  inline void clear_has_lost();
  inline void set_has_resync();
  inline void clear_has_resync();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 good_;
  ::google::protobuf::uint32 late_;
  ::google::protobuf::uint32 lost_;
  ::google::protobuf::uint32 resync_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static UserStats_Stats* default_instance_;
};
// -------------------------------------------------------------------

class UserStats : public ::google::protobuf::MessageLite {
 public:
  UserStats();
  virtual ~UserStats();

  UserStats(const UserStats& from);

  inline UserStats& operator=(const UserStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserStats* other);

  // implements Message ----------------------------------------------

  inline UserStats* New() const { return New(NULL); }

  UserStats* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserStats& from);
  void MergeFrom(const UserStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UserStats_Stats Stats;

  // accessors -------------------------------------------------------

  // optional uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // optional bool stats_only = 2 [default = false];
  inline bool has_stats_only() const;
  inline void clear_stats_only();
  static const int kStatsOnlyFieldNumber = 2;
  inline bool stats_only() const;
  inline void set_stats_only(bool value);

  // repeated bytes certificates = 3;
  inline int certificates_size() const;
  inline void clear_certificates();
  static const int kCertificatesFieldNumber = 3;
  inline const ::std::string& certificates(int index) const;
  inline ::std::string* mutable_certificates(int index);
  inline void set_certificates(int index, const ::std::string& value);
  inline void set_certificates(int index, const char* value);
  inline void set_certificates(int index, const void* value, size_t size);
  inline ::std::string* add_certificates();
  inline void add_certificates(const ::std::string& value);
  inline void add_certificates(const char* value);
  inline void add_certificates(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& certificates() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_certificates();

  // optional .MumbleProto.UserStats.Stats from_client = 4;
  inline bool has_from_client() const;
  inline void clear_from_client();
  static const int kFromClientFieldNumber = 4;
  inline const ::MumbleProto::UserStats_Stats& from_client() const;
  inline ::MumbleProto::UserStats_Stats* mutable_from_client();
  inline ::MumbleProto::UserStats_Stats* release_from_client();
  inline void set_allocated_from_client(::MumbleProto::UserStats_Stats* from_client);

  // optional .MumbleProto.UserStats.Stats from_server = 5;
  inline bool has_from_server() const;
  inline void clear_from_server();
  static const int kFromServerFieldNumber = 5;
  inline const ::MumbleProto::UserStats_Stats& from_server() const;
  inline ::MumbleProto::UserStats_Stats* mutable_from_server();
  inline ::MumbleProto::UserStats_Stats* release_from_server();
  inline void set_allocated_from_server(::MumbleProto::UserStats_Stats* from_server);

  // optional uint32 udp_packets = 6;
  inline bool has_udp_packets() const;
  inline void clear_udp_packets();
  static const int kUdpPacketsFieldNumber = 6;
  inline ::google::protobuf::uint32 udp_packets() const;
  inline void set_udp_packets(::google::protobuf::uint32 value);

  // optional uint32 tcp_packets = 7;
  inline bool has_tcp_packets() const;
  inline void clear_tcp_packets();
  static const int kTcpPacketsFieldNumber = 7;
  inline ::google::protobuf::uint32 tcp_packets() const;
  inline void set_tcp_packets(::google::protobuf::uint32 value);

  // optional float udp_ping_avg = 8;
  inline bool has_udp_ping_avg() const;
  inline void clear_udp_ping_avg();
  static const int kUdpPingAvgFieldNumber = 8;
  inline float udp_ping_avg() const;
  inline void set_udp_ping_avg(float value);

  // optional float udp_ping_var = 9;
  inline bool has_udp_ping_var() const;
  inline void clear_udp_ping_var();
  static const int kUdpPingVarFieldNumber = 9;
  inline float udp_ping_var() const;
  inline void set_udp_ping_var(float value);

  // optional float tcp_ping_avg = 10;
  inline bool has_tcp_ping_avg() const;
  inline void clear_tcp_ping_avg();
  static const int kTcpPingAvgFieldNumber = 10;
  inline float tcp_ping_avg() const;
  inline void set_tcp_ping_avg(float value);

  // optional float tcp_ping_var = 11;
  inline bool has_tcp_ping_var() const;
  inline void clear_tcp_ping_var();
  static const int kTcpPingVarFieldNumber = 11;
  inline float tcp_ping_var() const;
  inline void set_tcp_ping_var(float value);

  // optional .MumbleProto.Version version = 12;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 12;
  inline const ::MumbleProto::Version& version() const;
  inline ::MumbleProto::Version* mutable_version();
  inline ::MumbleProto::Version* release_version();
  inline void set_allocated_version(::MumbleProto::Version* version);

  // repeated int32 celt_versions = 13;
  inline int celt_versions_size() const;
  inline void clear_celt_versions();
  static const int kCeltVersionsFieldNumber = 13;
  inline ::google::protobuf::int32 celt_versions(int index) const;
  inline void set_celt_versions(int index, ::google::protobuf::int32 value);
  inline void add_celt_versions(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      celt_versions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_celt_versions();

  // optional bytes address = 14;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 14;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional uint32 bandwidth = 15;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 15;
  inline ::google::protobuf::uint32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::uint32 value);

  // optional uint32 onlinesecs = 16;
  inline bool has_onlinesecs() const;
  inline void clear_onlinesecs();
  static const int kOnlinesecsFieldNumber = 16;
  inline ::google::protobuf::uint32 onlinesecs() const;
  inline void set_onlinesecs(::google::protobuf::uint32 value);

  // optional uint32 idlesecs = 17;
  inline bool has_idlesecs() const;
  inline void clear_idlesecs();
  static const int kIdlesecsFieldNumber = 17;
  inline ::google::protobuf::uint32 idlesecs() const;
  inline void set_idlesecs(::google::protobuf::uint32 value);

  // optional bool strong_certificate = 18 [default = false];
  inline bool has_strong_certificate() const;
  inline void clear_strong_certificate();
  static const int kStrongCertificateFieldNumber = 18;
  inline bool strong_certificate() const;
  inline void set_strong_certificate(bool value);

  // optional bool opus = 19 [default = false];
  inline bool has_opus() const;
  inline void clear_opus();
  static const int kOpusFieldNumber = 19;
  inline bool opus() const;
  inline void set_opus(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserStats)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_stats_only();
  inline void clear_has_stats_only();
  inline void set_has_from_client();
  inline void clear_has_from_client();
  inline void set_has_from_server();
  inline void clear_has_from_server();
  inline void set_has_udp_packets();
  inline void clear_has_udp_packets();
  inline void set_has_tcp_packets();
  inline void clear_has_tcp_packets();
  inline void set_has_udp_ping_avg();
  inline void clear_has_udp_ping_avg();
  inline void set_has_udp_ping_var();
  inline void clear_has_udp_ping_var();
  inline void set_has_tcp_ping_avg();
  inline void clear_has_tcp_ping_avg();
  inline void set_has_tcp_ping_var();
  inline void clear_has_tcp_ping_var();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_onlinesecs();
  inline void clear_has_onlinesecs();
  inline void set_has_idlesecs();
  inline void clear_has_idlesecs();
  inline void set_has_strong_certificate();
  inline void clear_has_strong_certificate();
  inline void set_has_opus();
  inline void clear_has_opus();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> certificates_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 udp_packets_;
  ::MumbleProto::UserStats_Stats* from_client_;
  ::MumbleProto::UserStats_Stats* from_server_;
  ::google::protobuf::uint32 tcp_packets_;
  float udp_ping_avg_;
  float udp_ping_var_;
  float tcp_ping_avg_;
  ::MumbleProto::Version* version_;
  float tcp_ping_var_;
  bool stats_only_;
  bool strong_certificate_;
  bool opus_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > celt_versions_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::uint32 onlinesecs_;
  ::google::protobuf::uint32 idlesecs_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static UserStats* default_instance_;
};
// -------------------------------------------------------------------

class RequestBlob : public ::google::protobuf::MessageLite {
 public:
  RequestBlob();
  virtual ~RequestBlob();

  RequestBlob(const RequestBlob& from);

  inline RequestBlob& operator=(const RequestBlob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestBlob& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBlob* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBlob* other);

  // implements Message ----------------------------------------------

  inline RequestBlob* New() const { return New(NULL); }

  RequestBlob* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBlob& from);
  void MergeFrom(const RequestBlob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestBlob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 session_texture = 1;
  inline int session_texture_size() const;
  inline void clear_session_texture();
  static const int kSessionTextureFieldNumber = 1;
  inline ::google::protobuf::uint32 session_texture(int index) const;
  inline void set_session_texture(int index, ::google::protobuf::uint32 value);
  inline void add_session_texture(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session_texture() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session_texture();

  // repeated uint32 session_comment = 2;
  inline int session_comment_size() const;
  inline void clear_session_comment();
  static const int kSessionCommentFieldNumber = 2;
  inline ::google::protobuf::uint32 session_comment(int index) const;
  inline void set_session_comment(int index, ::google::protobuf::uint32 value);
  inline void add_session_comment(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session_comment() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session_comment();

  // repeated uint32 channel_description = 3;
  inline int channel_description_size() const;
  inline void clear_channel_description();
  static const int kChannelDescriptionFieldNumber = 3;
  inline ::google::protobuf::uint32 channel_description(int index) const;
  inline void set_channel_description(int index, ::google::protobuf::uint32 value);
  inline void add_channel_description(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      channel_description() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_channel_description();

  // @@protoc_insertion_point(class_scope:MumbleProto.RequestBlob)
 private:

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_texture_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_comment_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channel_description_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static RequestBlob* default_instance_;
};
// -------------------------------------------------------------------

class ServerConfig : public ::google::protobuf::MessageLite {
 public:
  ServerConfig();
  virtual ~ServerConfig();

  ServerConfig(const ServerConfig& from);

  inline ServerConfig& operator=(const ServerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerConfig* other);

  // implements Message ----------------------------------------------

  inline ServerConfig* New() const { return New(NULL); }

  ServerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerConfig& from);
  void MergeFrom(const ServerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 max_bandwidth = 1;
  inline bool has_max_bandwidth() const;
  inline void clear_max_bandwidth();
  static const int kMaxBandwidthFieldNumber = 1;
  inline ::google::protobuf::uint32 max_bandwidth() const;
  inline void set_max_bandwidth(::google::protobuf::uint32 value);

  // optional string welcome_text = 2;
  inline bool has_welcome_text() const;
  inline void clear_welcome_text();
  static const int kWelcomeTextFieldNumber = 2;
  inline const ::std::string& welcome_text() const;
  inline void set_welcome_text(const ::std::string& value);
  inline void set_welcome_text(const char* value);
  inline void set_welcome_text(const char* value, size_t size);
  inline ::std::string* mutable_welcome_text();
  inline ::std::string* release_welcome_text();
  inline void set_allocated_welcome_text(::std::string* welcome_text);

  // optional bool allow_html = 3;
  inline bool has_allow_html() const;
  inline void clear_allow_html();
  static const int kAllowHtmlFieldNumber = 3;
  inline bool allow_html() const;
  inline void set_allow_html(bool value);

  // optional uint32 message_length = 4;
  inline bool has_message_length() const;
  inline void clear_message_length();
  static const int kMessageLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 message_length() const;
  inline void set_message_length(::google::protobuf::uint32 value);

  // optional uint32 image_message_length = 5;
  inline bool has_image_message_length() const;
  inline void clear_image_message_length();
  static const int kImageMessageLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 image_message_length() const;
  inline void set_image_message_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ServerConfig)
 private:
  inline void set_has_max_bandwidth();
  inline void clear_has_max_bandwidth();
  inline void set_has_welcome_text();
  inline void clear_has_welcome_text();
  inline void set_has_allow_html();
  inline void clear_has_allow_html();
  inline void set_has_message_length();
  inline void clear_has_message_length();
  inline void set_has_image_message_length();
  inline void clear_has_image_message_length();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr welcome_text_;
  ::google::protobuf::uint32 max_bandwidth_;
  bool allow_html_;
  ::google::protobuf::uint32 message_length_;
  ::google::protobuf::uint32 image_message_length_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static ServerConfig* default_instance_;
};
// -------------------------------------------------------------------

class SuggestConfig : public ::google::protobuf::MessageLite {
 public:
  SuggestConfig();
  virtual ~SuggestConfig();

  SuggestConfig(const SuggestConfig& from);

  inline SuggestConfig& operator=(const SuggestConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SuggestConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SuggestConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SuggestConfig* other);

  // implements Message ----------------------------------------------

  inline SuggestConfig* New() const { return New(NULL); }

  SuggestConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SuggestConfig& from);
  void MergeFrom(const SuggestConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SuggestConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional bool positional = 2;
  inline bool has_positional() const;
  inline void clear_positional();
  static const int kPositionalFieldNumber = 2;
  inline bool positional() const;
  inline void set_positional(bool value);

  // optional bool push_to_talk = 3;
  inline bool has_push_to_talk() const;
  inline void clear_push_to_talk();
  static const int kPushToTalkFieldNumber = 3;
  inline bool push_to_talk() const;
  inline void set_push_to_talk(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.SuggestConfig)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_positional();
  inline void clear_has_positional();
  inline void set_has_push_to_talk();
  inline void clear_has_push_to_talk();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 version_;
  bool positional_;
  bool push_to_talk_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mumble_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mumble_2eproto();
  #endif
  friend void protobuf_AssignDesc_mumble_2eproto();
  friend void protobuf_ShutdownFile_mumble_2eproto();

  void InitAsDefaultInstance();
  static SuggestConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// Version

// optional uint32 version = 1;
inline bool Version::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Version::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Version::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Version::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Version::version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.version)
  return version_;
}
inline void Version::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Version.version)
}

// optional string release = 2;
inline bool Version::has_release() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Version::set_has_release() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Version::clear_has_release() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Version::clear_release() {
  release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_release();
}
inline const ::std::string& Version::release() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.release)
  return release_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_release(const ::std::string& value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.release)
}
inline void Version::set_release(const char* value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Version.release)
}
inline void Version::set_release(const char* value, size_t size) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.release)
}
inline ::std::string* Version::mutable_release() {
  set_has_release();
  // @@protoc_insertion_point(field_mutable:MumbleProto.Version.release)
  return release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Version::release_release() {
  clear_has_release();
  return release_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_allocated_release(::std::string* release) {
  if (release != NULL) {
    set_has_release();
  } else {
    clear_has_release();
  }
  release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.release)
}

// optional string os = 3;
inline bool Version::has_os() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Version::set_has_os() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Version::clear_has_os() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Version::clear_os() {
  os_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os();
}
inline const ::std::string& Version::os() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.os)
  return os_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_os(const ::std::string& value) {
  set_has_os();
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.os)
}
inline void Version::set_os(const char* value) {
  set_has_os();
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Version.os)
}
inline void Version::set_os(const char* value, size_t size) {
  set_has_os();
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.os)
}
inline ::std::string* Version::mutable_os() {
  set_has_os();
  // @@protoc_insertion_point(field_mutable:MumbleProto.Version.os)
  return os_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Version::release_os() {
  clear_has_os();
  return os_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_allocated_os(::std::string* os) {
  if (os != NULL) {
    set_has_os();
  } else {
    clear_has_os();
  }
  os_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.os)
}

// optional string os_version = 4;
inline bool Version::has_os_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Version::set_has_os_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Version::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Version::clear_os_version() {
  os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os_version();
}
inline const ::std::string& Version::os_version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.os_version)
  return os_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_os_version(const ::std::string& value) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.os_version)
}
inline void Version::set_os_version(const char* value) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Version.os_version)
}
inline void Version::set_os_version(const char* value, size_t size) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.os_version)
}
inline ::std::string* Version::mutable_os_version() {
  set_has_os_version();
  // @@protoc_insertion_point(field_mutable:MumbleProto.Version.os_version)
  return os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Version::release_os_version() {
  clear_has_os_version();
  return os_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_allocated_os_version(::std::string* os_version) {
  if (os_version != NULL) {
    set_has_os_version();
  } else {
    clear_has_os_version();
  }
  os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_version);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.os_version)
}

// -------------------------------------------------------------------

// UDPTunnel

// required bytes packet = 1;
inline bool UDPTunnel::has_packet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UDPTunnel::set_has_packet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UDPTunnel::clear_has_packet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UDPTunnel::clear_packet() {
  packet_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packet();
}
inline const ::std::string& UDPTunnel::packet() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UDPTunnel.packet)
  return packet_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UDPTunnel::set_packet(const ::std::string& value) {
  set_has_packet();
  packet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UDPTunnel.packet)
}
inline void UDPTunnel::set_packet(const char* value) {
  set_has_packet();
  packet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UDPTunnel.packet)
}
inline void UDPTunnel::set_packet(const void* value, size_t size) {
  set_has_packet();
  packet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UDPTunnel.packet)
}
inline ::std::string* UDPTunnel::mutable_packet() {
  set_has_packet();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UDPTunnel.packet)
  return packet_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UDPTunnel::release_packet() {
  clear_has_packet();
  return packet_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UDPTunnel::set_allocated_packet(::std::string* packet) {
  if (packet != NULL) {
    set_has_packet();
  } else {
    clear_has_packet();
  }
  packet_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packet);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UDPTunnel.packet)
}

// -------------------------------------------------------------------

// Authenticate

// optional string username = 1;
inline bool Authenticate::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticate::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authenticate::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authenticate::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& Authenticate::username() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticate::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.username)
}
inline void Authenticate::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.username)
}
inline void Authenticate::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.username)
}
inline ::std::string* Authenticate::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticate::release_username() {
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticate::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Authenticate.username)
}

// optional string password = 2;
inline bool Authenticate::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authenticate::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authenticate::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authenticate::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& Authenticate::password() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticate::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.password)
}
inline void Authenticate::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.password)
}
inline void Authenticate::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.password)
}
inline ::std::string* Authenticate::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticate::release_password() {
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticate::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Authenticate.password)
}

// repeated string tokens = 3;
inline int Authenticate::tokens_size() const {
  return tokens_.size();
}
inline void Authenticate::clear_tokens() {
  tokens_.Clear();
}
inline const ::std::string& Authenticate::tokens(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.tokens)
  return tokens_.Get(index);
}
inline ::std::string* Authenticate::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.tokens)
  return tokens_.Mutable(index);
}
inline void Authenticate::set_tokens(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.tokens)
  tokens_.Mutable(index)->assign(value);
}
inline void Authenticate::set_tokens(int index, const char* value) {
  tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.tokens)
}
inline void Authenticate::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.tokens)
}
inline ::std::string* Authenticate::add_tokens() {
  return tokens_.Add();
}
inline void Authenticate::add_tokens(const ::std::string& value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.tokens)
}
inline void Authenticate::add_tokens(const char* value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MumbleProto.Authenticate.tokens)
}
inline void Authenticate::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MumbleProto.Authenticate.tokens)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Authenticate::tokens() const {
  // @@protoc_insertion_point(field_list:MumbleProto.Authenticate.tokens)
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Authenticate::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.Authenticate.tokens)
  return &tokens_;
}

// repeated int32 celt_versions = 4;
inline int Authenticate::celt_versions_size() const {
  return celt_versions_.size();
}
inline void Authenticate::clear_celt_versions() {
  celt_versions_.Clear();
}
inline ::google::protobuf::int32 Authenticate::celt_versions(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.celt_versions)
  return celt_versions_.Get(index);
}
inline void Authenticate::set_celt_versions(int index, ::google::protobuf::int32 value) {
  celt_versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.celt_versions)
}
inline void Authenticate::add_celt_versions(::google::protobuf::int32 value) {
  celt_versions_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.celt_versions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Authenticate::celt_versions() const {
  // @@protoc_insertion_point(field_list:MumbleProto.Authenticate.celt_versions)
  return celt_versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Authenticate::mutable_celt_versions() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.Authenticate.celt_versions)
  return &celt_versions_;
}

// optional bool opus = 5 [default = false];
inline bool Authenticate::has_opus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Authenticate::set_has_opus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Authenticate::clear_has_opus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Authenticate::clear_opus() {
  opus_ = false;
  clear_has_opus();
}
inline bool Authenticate::opus() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.opus)
  return opus_;
}
inline void Authenticate::set_opus(bool value) {
  set_has_opus();
  opus_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.opus)
}

// -------------------------------------------------------------------

// Ping

// optional uint64 timestamp = 1;
inline bool Ping::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.timestamp)
  return timestamp_;
}
inline void Ping::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.timestamp)
}

// optional uint32 good = 2;
inline bool Ping::has_good() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ping::set_has_good() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ping::clear_has_good() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ping::clear_good() {
  good_ = 0u;
  clear_has_good();
}
inline ::google::protobuf::uint32 Ping::good() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.good)
  return good_;
}
inline void Ping::set_good(::google::protobuf::uint32 value) {
  set_has_good();
  good_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.good)
}

// optional uint32 late = 3;
inline bool Ping::has_late() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ping::set_has_late() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ping::clear_has_late() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ping::clear_late() {
  late_ = 0u;
  clear_has_late();
}
inline ::google::protobuf::uint32 Ping::late() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.late)
  return late_;
}
inline void Ping::set_late(::google::protobuf::uint32 value) {
  set_has_late();
  late_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.late)
}

// optional uint32 lost = 4;
inline bool Ping::has_lost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ping::set_has_lost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ping::clear_has_lost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ping::clear_lost() {
  lost_ = 0u;
  clear_has_lost();
}
inline ::google::protobuf::uint32 Ping::lost() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.lost)
  return lost_;
}
inline void Ping::set_lost(::google::protobuf::uint32 value) {
  set_has_lost();
  lost_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.lost)
}

// optional uint32 resync = 5;
inline bool Ping::has_resync() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ping::set_has_resync() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ping::clear_has_resync() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ping::clear_resync() {
  resync_ = 0u;
  clear_has_resync();
}
inline ::google::protobuf::uint32 Ping::resync() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.resync)
  return resync_;
}
inline void Ping::set_resync(::google::protobuf::uint32 value) {
  set_has_resync();
  resync_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.resync)
}

// optional uint32 udp_packets = 6;
inline bool Ping::has_udp_packets() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ping::set_has_udp_packets() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ping::clear_has_udp_packets() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ping::clear_udp_packets() {
  udp_packets_ = 0u;
  clear_has_udp_packets();
}
inline ::google::protobuf::uint32 Ping::udp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_packets)
  return udp_packets_;
}
inline void Ping::set_udp_packets(::google::protobuf::uint32 value) {
  set_has_udp_packets();
  udp_packets_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_packets)
}

// optional uint32 tcp_packets = 7;
inline bool Ping::has_tcp_packets() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ping::set_has_tcp_packets() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ping::clear_has_tcp_packets() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ping::clear_tcp_packets() {
  tcp_packets_ = 0u;
  clear_has_tcp_packets();
}
inline ::google::protobuf::uint32 Ping::tcp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_packets)
  return tcp_packets_;
}
inline void Ping::set_tcp_packets(::google::protobuf::uint32 value) {
  set_has_tcp_packets();
  tcp_packets_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_packets)
}

// optional float udp_ping_avg = 8;
inline bool Ping::has_udp_ping_avg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ping::set_has_udp_ping_avg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ping::clear_has_udp_ping_avg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ping::clear_udp_ping_avg() {
  udp_ping_avg_ = 0;
  clear_has_udp_ping_avg();
}
inline float Ping::udp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_ping_avg)
  return udp_ping_avg_;
}
inline void Ping::set_udp_ping_avg(float value) {
  set_has_udp_ping_avg();
  udp_ping_avg_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_ping_avg)
}

// optional float udp_ping_var = 9;
inline bool Ping::has_udp_ping_var() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ping::set_has_udp_ping_var() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ping::clear_has_udp_ping_var() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ping::clear_udp_ping_var() {
  udp_ping_var_ = 0;
  clear_has_udp_ping_var();
}
inline float Ping::udp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_ping_var)
  return udp_ping_var_;
}
inline void Ping::set_udp_ping_var(float value) {
  set_has_udp_ping_var();
  udp_ping_var_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_ping_var)
}

// optional float tcp_ping_avg = 10;
inline bool Ping::has_tcp_ping_avg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ping::set_has_tcp_ping_avg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ping::clear_has_tcp_ping_avg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ping::clear_tcp_ping_avg() {
  tcp_ping_avg_ = 0;
  clear_has_tcp_ping_avg();
}
inline float Ping::tcp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_ping_avg)
  return tcp_ping_avg_;
}
inline void Ping::set_tcp_ping_avg(float value) {
  set_has_tcp_ping_avg();
  tcp_ping_avg_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_ping_avg)
}

// optional float tcp_ping_var = 11;
inline bool Ping::has_tcp_ping_var() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ping::set_has_tcp_ping_var() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Ping::clear_has_tcp_ping_var() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Ping::clear_tcp_ping_var() {
  tcp_ping_var_ = 0;
  clear_has_tcp_ping_var();
}
inline float Ping::tcp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_ping_var)
  return tcp_ping_var_;
}
inline void Ping::set_tcp_ping_var(float value) {
  set_has_tcp_ping_var();
  tcp_ping_var_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_ping_var)
}

// -------------------------------------------------------------------

// Reject

// optional .MumbleProto.Reject.RejectType type = 1;
inline bool Reject::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reject::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reject::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reject::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::MumbleProto::Reject_RejectType Reject::type() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Reject.type)
  return static_cast< ::MumbleProto::Reject_RejectType >(type_);
}
inline void Reject::set_type(::MumbleProto::Reject_RejectType value) {
  assert(::MumbleProto::Reject_RejectType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Reject.type)
}

// optional string reason = 2;
inline bool Reject::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reject::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reject::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reject::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& Reject::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Reject.reason)
  return reason_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reject::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Reject.reason)
}
inline void Reject::set_reason(const char* value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Reject.reason)
}
inline void Reject::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Reject.reason)
}
inline ::std::string* Reject::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:MumbleProto.Reject.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Reject::release_reason() {
  clear_has_reason();
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reject::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Reject.reason)
}

// -------------------------------------------------------------------

// ServerSync

// optional uint32 session = 1;
inline bool ServerSync::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerSync::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerSync::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerSync::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 ServerSync::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.session)
  return session_;
}
inline void ServerSync::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.session)
}

// optional uint32 max_bandwidth = 2;
inline bool ServerSync::has_max_bandwidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerSync::set_has_max_bandwidth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerSync::clear_has_max_bandwidth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerSync::clear_max_bandwidth() {
  max_bandwidth_ = 0u;
  clear_has_max_bandwidth();
}
inline ::google::protobuf::uint32 ServerSync::max_bandwidth() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.max_bandwidth)
  return max_bandwidth_;
}
inline void ServerSync::set_max_bandwidth(::google::protobuf::uint32 value) {
  set_has_max_bandwidth();
  max_bandwidth_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.max_bandwidth)
}

// optional string welcome_text = 3;
inline bool ServerSync::has_welcome_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerSync::set_has_welcome_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerSync::clear_has_welcome_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerSync::clear_welcome_text() {
  welcome_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_welcome_text();
}
inline const ::std::string& ServerSync::welcome_text() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.welcome_text)
  return welcome_text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerSync::set_welcome_text(const ::std::string& value) {
  set_has_welcome_text();
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.welcome_text)
}
inline void ServerSync::set_welcome_text(const char* value) {
  set_has_welcome_text();
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ServerSync.welcome_text)
}
inline void ServerSync::set_welcome_text(const char* value, size_t size) {
  set_has_welcome_text();
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ServerSync.welcome_text)
}
inline ::std::string* ServerSync::mutable_welcome_text() {
  set_has_welcome_text();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ServerSync.welcome_text)
  return welcome_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerSync::release_welcome_text() {
  clear_has_welcome_text();
  return welcome_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerSync::set_allocated_welcome_text(::std::string* welcome_text) {
  if (welcome_text != NULL) {
    set_has_welcome_text();
  } else {
    clear_has_welcome_text();
  }
  welcome_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), welcome_text);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ServerSync.welcome_text)
}

// optional uint64 permissions = 4;
inline bool ServerSync::has_permissions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerSync::set_has_permissions() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerSync::clear_has_permissions() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerSync::clear_permissions() {
  permissions_ = GOOGLE_ULONGLONG(0);
  clear_has_permissions();
}
inline ::google::protobuf::uint64 ServerSync::permissions() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.permissions)
  return permissions_;
}
inline void ServerSync::set_permissions(::google::protobuf::uint64 value) {
  set_has_permissions();
  permissions_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.permissions)
}

// -------------------------------------------------------------------

// ChannelRemove

// required uint32 channel_id = 1;
inline bool ChannelRemove::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelRemove::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChannelRemove::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChannelRemove::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 ChannelRemove::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelRemove.channel_id)
  return channel_id_;
}
inline void ChannelRemove::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelRemove.channel_id)
}

// -------------------------------------------------------------------

// ChannelState

// optional uint32 channel_id = 1;
inline bool ChannelState::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelState::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChannelState::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChannelState::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 ChannelState::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.channel_id)
  return channel_id_;
}
inline void ChannelState::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.channel_id)
}

// optional uint32 parent = 2;
inline bool ChannelState::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChannelState::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChannelState::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChannelState::clear_parent() {
  parent_ = 0u;
  clear_has_parent();
}
inline ::google::protobuf::uint32 ChannelState::parent() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.parent)
  return parent_;
}
inline void ChannelState::set_parent(::google::protobuf::uint32 value) {
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.parent)
}

// optional string name = 3;
inline bool ChannelState::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChannelState::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChannelState::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChannelState::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ChannelState::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelState::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.name)
}
inline void ChannelState::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.name)
}
inline void ChannelState::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.name)
}
inline ::std::string* ChannelState::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelState::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelState::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.name)
}

// repeated uint32 links = 4;
inline int ChannelState::links_size() const {
  return links_.size();
}
inline void ChannelState::clear_links() {
  links_.Clear();
}
inline ::google::protobuf::uint32 ChannelState::links(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links)
  return links_.Get(index);
}
inline void ChannelState::set_links(int index, ::google::protobuf::uint32 value) {
  links_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links)
}
inline void ChannelState::add_links(::google::protobuf::uint32 value) {
  links_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChannelState::links() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links)
  return links_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChannelState::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links)
  return &links_;
}

// optional string description = 5;
inline bool ChannelState::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChannelState::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChannelState::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChannelState::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& ChannelState::description() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelState::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.description)
}
inline void ChannelState::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.description)
}
inline void ChannelState::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.description)
}
inline ::std::string* ChannelState::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelState::release_description() {
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelState::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.description)
}

// repeated uint32 links_add = 6;
inline int ChannelState::links_add_size() const {
  return links_add_.size();
}
inline void ChannelState::clear_links_add() {
  links_add_.Clear();
}
inline ::google::protobuf::uint32 ChannelState::links_add(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links_add)
  return links_add_.Get(index);
}
inline void ChannelState::set_links_add(int index, ::google::protobuf::uint32 value) {
  links_add_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links_add)
}
inline void ChannelState::add_links_add(::google::protobuf::uint32 value) {
  links_add_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links_add)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChannelState::links_add() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links_add)
  return links_add_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChannelState::mutable_links_add() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links_add)
  return &links_add_;
}

// repeated uint32 links_remove = 7;
inline int ChannelState::links_remove_size() const {
  return links_remove_.size();
}
inline void ChannelState::clear_links_remove() {
  links_remove_.Clear();
}
inline ::google::protobuf::uint32 ChannelState::links_remove(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links_remove)
  return links_remove_.Get(index);
}
inline void ChannelState::set_links_remove(int index, ::google::protobuf::uint32 value) {
  links_remove_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links_remove)
}
inline void ChannelState::add_links_remove(::google::protobuf::uint32 value) {
  links_remove_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links_remove)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChannelState::links_remove() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links_remove)
  return links_remove_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChannelState::mutable_links_remove() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links_remove)
  return &links_remove_;
}

// optional bool temporary = 8 [default = false];
inline bool ChannelState::has_temporary() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChannelState::set_has_temporary() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChannelState::clear_has_temporary() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChannelState::clear_temporary() {
  temporary_ = false;
  clear_has_temporary();
}
inline bool ChannelState::temporary() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.temporary)
  return temporary_;
}
inline void ChannelState::set_temporary(bool value) {
  set_has_temporary();
  temporary_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.temporary)
}

// optional int32 position = 9 [default = 0];
inline bool ChannelState::has_position() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChannelState::set_has_position() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChannelState::clear_has_position() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChannelState::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 ChannelState::position() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.position)
  return position_;
}
inline void ChannelState::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.position)
}

// optional bytes description_hash = 10;
inline bool ChannelState::has_description_hash() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ChannelState::set_has_description_hash() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ChannelState::clear_has_description_hash() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ChannelState::clear_description_hash() {
  description_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description_hash();
}
inline const ::std::string& ChannelState::description_hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.description_hash)
  return description_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelState::set_description_hash(const ::std::string& value) {
  set_has_description_hash();
  description_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.description_hash)
}
inline void ChannelState::set_description_hash(const char* value) {
  set_has_description_hash();
  description_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.description_hash)
}
inline void ChannelState::set_description_hash(const void* value, size_t size) {
  set_has_description_hash();
  description_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.description_hash)
}
inline ::std::string* ChannelState::mutable_description_hash() {
  set_has_description_hash();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.description_hash)
  return description_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelState::release_description_hash() {
  clear_has_description_hash();
  return description_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelState::set_allocated_description_hash(::std::string* description_hash) {
  if (description_hash != NULL) {
    set_has_description_hash();
  } else {
    clear_has_description_hash();
  }
  description_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description_hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.description_hash)
}

// -------------------------------------------------------------------

// UserRemove

// required uint32 session = 1;
inline bool UserRemove::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRemove::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRemove::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRemove::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 UserRemove::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.session)
  return session_;
}
inline void UserRemove::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.session)
}

// optional uint32 actor = 2;
inline bool UserRemove::has_actor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRemove::set_has_actor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRemove::clear_has_actor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRemove::clear_actor() {
  actor_ = 0u;
  clear_has_actor();
}
inline ::google::protobuf::uint32 UserRemove::actor() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.actor)
  return actor_;
}
inline void UserRemove::set_actor(::google::protobuf::uint32 value) {
  set_has_actor();
  actor_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.actor)
}

// optional string reason = 3;
inline bool UserRemove::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRemove::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserRemove::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserRemove::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& UserRemove::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.reason)
  return reason_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRemove::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.reason)
}
inline void UserRemove::set_reason(const char* value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserRemove.reason)
}
inline void UserRemove::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserRemove.reason)
}
inline ::std::string* UserRemove::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserRemove.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRemove::release_reason() {
  clear_has_reason();
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRemove::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserRemove.reason)
}

// optional bool ban = 4;
inline bool UserRemove::has_ban() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserRemove::set_has_ban() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserRemove::clear_has_ban() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserRemove::clear_ban() {
  ban_ = false;
  clear_has_ban();
}
inline bool UserRemove::ban() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.ban)
  return ban_;
}
inline void UserRemove::set_ban(bool value) {
  set_has_ban();
  ban_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.ban)
}

// -------------------------------------------------------------------

// UserState

// optional uint32 session = 1;
inline bool UserState::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserState::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserState::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserState::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 UserState::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.session)
  return session_;
}
inline void UserState::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.session)
}

// optional uint32 actor = 2;
inline bool UserState::has_actor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserState::set_has_actor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserState::clear_has_actor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserState::clear_actor() {
  actor_ = 0u;
  clear_has_actor();
}
inline ::google::protobuf::uint32 UserState::actor() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.actor)
  return actor_;
}
inline void UserState::set_actor(::google::protobuf::uint32 value) {
  set_has_actor();
  actor_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.actor)
}

// optional string name = 3;
inline bool UserState::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserState::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserState::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserState::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& UserState::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.name)
}
inline void UserState::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.name)
}
inline void UserState::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.name)
}
inline ::std::string* UserState::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.name)
}

// optional uint32 user_id = 4;
inline bool UserState::has_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserState::set_has_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserState::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserState::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserState::user_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.user_id)
  return user_id_;
}
inline void UserState::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.user_id)
}

// optional uint32 channel_id = 5;
inline bool UserState::has_channel_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserState::set_has_channel_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserState::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserState::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 UserState::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.channel_id)
  return channel_id_;
}
inline void UserState::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.channel_id)
}

// optional bool mute = 6;
inline bool UserState::has_mute() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserState::set_has_mute() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserState::clear_has_mute() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserState::clear_mute() {
  mute_ = false;
  clear_has_mute();
}
inline bool UserState::mute() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.mute)
  return mute_;
}
inline void UserState::set_mute(bool value) {
  set_has_mute();
  mute_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.mute)
}

// optional bool deaf = 7;
inline bool UserState::has_deaf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserState::set_has_deaf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserState::clear_has_deaf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserState::clear_deaf() {
  deaf_ = false;
  clear_has_deaf();
}
inline bool UserState::deaf() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.deaf)
  return deaf_;
}
inline void UserState::set_deaf(bool value) {
  set_has_deaf();
  deaf_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.deaf)
}

// optional bool suppress = 8;
inline bool UserState::has_suppress() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserState::set_has_suppress() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserState::clear_has_suppress() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserState::clear_suppress() {
  suppress_ = false;
  clear_has_suppress();
}
inline bool UserState::suppress() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.suppress)
  return suppress_;
}
inline void UserState::set_suppress(bool value) {
  set_has_suppress();
  suppress_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.suppress)
}

// optional bool self_mute = 9;
inline bool UserState::has_self_mute() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserState::set_has_self_mute() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserState::clear_has_self_mute() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserState::clear_self_mute() {
  self_mute_ = false;
  clear_has_self_mute();
}
inline bool UserState::self_mute() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.self_mute)
  return self_mute_;
}
inline void UserState::set_self_mute(bool value) {
  set_has_self_mute();
  self_mute_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.self_mute)
}

// optional bool self_deaf = 10;
inline bool UserState::has_self_deaf() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserState::set_has_self_deaf() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserState::clear_has_self_deaf() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserState::clear_self_deaf() {
  self_deaf_ = false;
  clear_has_self_deaf();
}
inline bool UserState::self_deaf() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.self_deaf)
  return self_deaf_;
}
inline void UserState::set_self_deaf(bool value) {
  set_has_self_deaf();
  self_deaf_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.self_deaf)
}

// optional bytes texture = 11;
inline bool UserState::has_texture() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserState::set_has_texture() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserState::clear_has_texture() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserState::clear_texture() {
  texture_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_texture();
}
inline const ::std::string& UserState::texture() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.texture)
  return texture_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_texture(const ::std::string& value) {
  set_has_texture();
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.texture)
}
inline void UserState::set_texture(const char* value) {
  set_has_texture();
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.texture)
}
inline void UserState::set_texture(const void* value, size_t size) {
  set_has_texture();
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.texture)
}
inline ::std::string* UserState::mutable_texture() {
  set_has_texture();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.texture)
  return texture_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_texture() {
  clear_has_texture();
  return texture_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_texture(::std::string* texture) {
  if (texture != NULL) {
    set_has_texture();
  } else {
    clear_has_texture();
  }
  texture_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), texture);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.texture)
}

// optional bytes plugin_context = 12;
inline bool UserState::has_plugin_context() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserState::set_has_plugin_context() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserState::clear_has_plugin_context() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserState::clear_plugin_context() {
  plugin_context_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_plugin_context();
}
inline const ::std::string& UserState::plugin_context() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.plugin_context)
  return plugin_context_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_plugin_context(const ::std::string& value) {
  set_has_plugin_context();
  plugin_context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.plugin_context)
}
inline void UserState::set_plugin_context(const char* value) {
  set_has_plugin_context();
  plugin_context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.plugin_context)
}
inline void UserState::set_plugin_context(const void* value, size_t size) {
  set_has_plugin_context();
  plugin_context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.plugin_context)
}
inline ::std::string* UserState::mutable_plugin_context() {
  set_has_plugin_context();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.plugin_context)
  return plugin_context_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_plugin_context() {
  clear_has_plugin_context();
  return plugin_context_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_plugin_context(::std::string* plugin_context) {
  if (plugin_context != NULL) {
    set_has_plugin_context();
  } else {
    clear_has_plugin_context();
  }
  plugin_context_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plugin_context);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.plugin_context)
}

// optional string plugin_identity = 13;
inline bool UserState::has_plugin_identity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserState::set_has_plugin_identity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserState::clear_has_plugin_identity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserState::clear_plugin_identity() {
  plugin_identity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_plugin_identity();
}
inline const ::std::string& UserState::plugin_identity() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.plugin_identity)
  return plugin_identity_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_plugin_identity(const ::std::string& value) {
  set_has_plugin_identity();
  plugin_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.plugin_identity)
}
inline void UserState::set_plugin_identity(const char* value) {
  set_has_plugin_identity();
  plugin_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.plugin_identity)
}
inline void UserState::set_plugin_identity(const char* value, size_t size) {
  set_has_plugin_identity();
  plugin_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.plugin_identity)
}
inline ::std::string* UserState::mutable_plugin_identity() {
  set_has_plugin_identity();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.plugin_identity)
  return plugin_identity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_plugin_identity() {
  clear_has_plugin_identity();
  return plugin_identity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_plugin_identity(::std::string* plugin_identity) {
  if (plugin_identity != NULL) {
    set_has_plugin_identity();
  } else {
    clear_has_plugin_identity();
  }
  plugin_identity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plugin_identity);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.plugin_identity)
}

// optional string comment = 14;
inline bool UserState::has_comment() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserState::set_has_comment() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserState::clear_has_comment() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserState::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& UserState::comment() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.comment)
  return comment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.comment)
}
inline void UserState::set_comment(const char* value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.comment)
}
inline void UserState::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.comment)
}
inline ::std::string* UserState::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_comment() {
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.comment)
}

// optional string hash = 15;
inline bool UserState::has_hash() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserState::set_has_hash() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserState::clear_has_hash() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserState::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& UserState::hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.hash)
}
inline void UserState::set_hash(const char* value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.hash)
}
inline void UserState::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.hash)
}
inline ::std::string* UserState::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_hash() {
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.hash)
}

// optional bytes comment_hash = 16;
inline bool UserState::has_comment_hash() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserState::set_has_comment_hash() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserState::clear_has_comment_hash() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserState::clear_comment_hash() {
  comment_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment_hash();
}
inline const ::std::string& UserState::comment_hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.comment_hash)
  return comment_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_comment_hash(const ::std::string& value) {
  set_has_comment_hash();
  comment_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.comment_hash)
}
inline void UserState::set_comment_hash(const char* value) {
  set_has_comment_hash();
  comment_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.comment_hash)
}
inline void UserState::set_comment_hash(const void* value, size_t size) {
  set_has_comment_hash();
  comment_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.comment_hash)
}
inline ::std::string* UserState::mutable_comment_hash() {
  set_has_comment_hash();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.comment_hash)
  return comment_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_comment_hash() {
  clear_has_comment_hash();
  return comment_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_comment_hash(::std::string* comment_hash) {
  if (comment_hash != NULL) {
    set_has_comment_hash();
  } else {
    clear_has_comment_hash();
  }
  comment_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment_hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.comment_hash)
}

// optional bytes texture_hash = 17;
inline bool UserState::has_texture_hash() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserState::set_has_texture_hash() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserState::clear_has_texture_hash() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserState::clear_texture_hash() {
  texture_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_texture_hash();
}
inline const ::std::string& UserState::texture_hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.texture_hash)
  return texture_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_texture_hash(const ::std::string& value) {
  set_has_texture_hash();
  texture_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.texture_hash)
}
inline void UserState::set_texture_hash(const char* value) {
  set_has_texture_hash();
  texture_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.texture_hash)
}
inline void UserState::set_texture_hash(const void* value, size_t size) {
  set_has_texture_hash();
  texture_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.texture_hash)
}
inline ::std::string* UserState::mutable_texture_hash() {
  set_has_texture_hash();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.texture_hash)
  return texture_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_texture_hash() {
  clear_has_texture_hash();
  return texture_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_texture_hash(::std::string* texture_hash) {
  if (texture_hash != NULL) {
    set_has_texture_hash();
  } else {
    clear_has_texture_hash();
  }
  texture_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), texture_hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.texture_hash)
}

// optional bool priority_speaker = 18;
inline bool UserState::has_priority_speaker() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UserState::set_has_priority_speaker() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UserState::clear_has_priority_speaker() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UserState::clear_priority_speaker() {
  priority_speaker_ = false;
  clear_has_priority_speaker();
}
inline bool UserState::priority_speaker() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.priority_speaker)
  return priority_speaker_;
}
inline void UserState::set_priority_speaker(bool value) {
  set_has_priority_speaker();
  priority_speaker_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.priority_speaker)
}

// optional bool recording = 19;
inline bool UserState::has_recording() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UserState::set_has_recording() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UserState::clear_has_recording() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UserState::clear_recording() {
  recording_ = false;
  clear_has_recording();
}
inline bool UserState::recording() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.recording)
  return recording_;
}
inline void UserState::set_recording(bool value) {
  set_has_recording();
  recording_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.recording)
}

// -------------------------------------------------------------------

// BanList_BanEntry

// required bytes address = 1;
inline bool BanList_BanEntry::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BanList_BanEntry::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BanList_BanEntry::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BanList_BanEntry::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& BanList_BanEntry::address() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.address)
  return address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.address)
}
inline void BanList_BanEntry::set_address(const char* value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.address)
}
inline void BanList_BanEntry::set_address(const void* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.address)
}
inline ::std::string* BanList_BanEntry::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_address() {
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.address)
}

// required uint32 mask = 2;
inline bool BanList_BanEntry::has_mask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BanList_BanEntry::set_has_mask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BanList_BanEntry::clear_has_mask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BanList_BanEntry::clear_mask() {
  mask_ = 0u;
  clear_has_mask();
}
inline ::google::protobuf::uint32 BanList_BanEntry::mask() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.mask)
  return mask_;
}
inline void BanList_BanEntry::set_mask(::google::protobuf::uint32 value) {
  set_has_mask();
  mask_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.mask)
}

// optional string name = 3;
inline bool BanList_BanEntry::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BanList_BanEntry::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BanList_BanEntry::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BanList_BanEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& BanList_BanEntry::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.name)
}
inline void BanList_BanEntry::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.name)
}
inline void BanList_BanEntry::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.name)
}
inline ::std::string* BanList_BanEntry::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.name)
}

// optional string hash = 4;
inline bool BanList_BanEntry::has_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BanList_BanEntry::set_has_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BanList_BanEntry::clear_has_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BanList_BanEntry::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& BanList_BanEntry::hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.hash)
}
inline void BanList_BanEntry::set_hash(const char* value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.hash)
}
inline void BanList_BanEntry::set_hash(const char* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.hash)
}
inline ::std::string* BanList_BanEntry::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_hash() {
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.hash)
}

// optional string reason = 5;
inline bool BanList_BanEntry::has_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BanList_BanEntry::set_has_reason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BanList_BanEntry::clear_has_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BanList_BanEntry::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& BanList_BanEntry::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.reason)
  return reason_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.reason)
}
inline void BanList_BanEntry::set_reason(const char* value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.reason)
}
inline void BanList_BanEntry::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.reason)
}
inline ::std::string* BanList_BanEntry::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_reason() {
  clear_has_reason();
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.reason)
}

// optional string start = 6;
inline bool BanList_BanEntry::has_start() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BanList_BanEntry::set_has_start() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BanList_BanEntry::clear_has_start() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BanList_BanEntry::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_start();
}
inline const ::std::string& BanList_BanEntry::start() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.start)
  return start_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_start(const ::std::string& value) {
  set_has_start();
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.start)
}
inline void BanList_BanEntry::set_start(const char* value) {
  set_has_start();
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.start)
}
inline void BanList_BanEntry::set_start(const char* value, size_t size) {
  set_has_start();
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.start)
}
inline ::std::string* BanList_BanEntry::mutable_start() {
  set_has_start();
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_start() {
  clear_has_start();
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    set_has_start();
  } else {
    clear_has_start();
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.start)
}

// optional uint32 duration = 7;
inline bool BanList_BanEntry::has_duration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BanList_BanEntry::set_has_duration() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BanList_BanEntry::clear_has_duration() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BanList_BanEntry::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 BanList_BanEntry::duration() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.duration)
  return duration_;
}
inline void BanList_BanEntry::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.duration)
}

// -------------------------------------------------------------------

// BanList

// repeated .MumbleProto.BanList.BanEntry bans = 1;
inline int BanList::bans_size() const {
  return bans_.size();
}
inline void BanList::clear_bans() {
  bans_.Clear();
}
inline const ::MumbleProto::BanList_BanEntry& BanList::bans(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.bans)
  return bans_.Get(index);
}
inline ::MumbleProto::BanList_BanEntry* BanList::mutable_bans(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.bans)
  return bans_.Mutable(index);
}
inline ::MumbleProto::BanList_BanEntry* BanList::add_bans() {
  // @@protoc_insertion_point(field_add:MumbleProto.BanList.bans)
  return bans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
BanList::bans() const {
  // @@protoc_insertion_point(field_list:MumbleProto.BanList.bans)
  return bans_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
BanList::mutable_bans() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.BanList.bans)
  return &bans_;
}

// optional bool query = 2 [default = false];
inline bool BanList::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BanList::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BanList::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BanList::clear_query() {
  query_ = false;
  clear_has_query();
}
inline bool BanList::query() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.query)
  return query_;
}
inline void BanList::set_query(bool value) {
  set_has_query();
  query_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.query)
}

// -------------------------------------------------------------------

// TextMessage

// optional uint32 actor = 1;
inline bool TextMessage::has_actor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextMessage::set_has_actor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextMessage::clear_has_actor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextMessage::clear_actor() {
  actor_ = 0u;
  clear_has_actor();
}
inline ::google::protobuf::uint32 TextMessage::actor() const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.actor)
  return actor_;
}
inline void TextMessage::set_actor(::google::protobuf::uint32 value) {
  set_has_actor();
  actor_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.actor)
}

// repeated uint32 session = 2;
inline int TextMessage::session_size() const {
  return session_.size();
}
inline void TextMessage::clear_session() {
  session_.Clear();
}
inline ::google::protobuf::uint32 TextMessage::session(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.session)
  return session_.Get(index);
}
inline void TextMessage::set_session(int index, ::google::protobuf::uint32 value) {
  session_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.session)
}
inline void TextMessage::add_session(::google::protobuf::uint32 value) {
  session_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.session)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TextMessage::session() const {
  // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.session)
  return session_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TextMessage::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.session)
  return &session_;
}

// repeated uint32 channel_id = 3;
inline int TextMessage::channel_id_size() const {
  return channel_id_.size();
}
inline void TextMessage::clear_channel_id() {
  channel_id_.Clear();
}
inline ::google::protobuf::uint32 TextMessage::channel_id(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.channel_id)
  return channel_id_.Get(index);
}
inline void TextMessage::set_channel_id(int index, ::google::protobuf::uint32 value) {
  channel_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.channel_id)
}
inline void TextMessage::add_channel_id(::google::protobuf::uint32 value) {
  channel_id_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.channel_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TextMessage::channel_id() const {
  // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.channel_id)
  return channel_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TextMessage::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.channel_id)
  return &channel_id_;
}

// repeated uint32 tree_id = 4;
inline int TextMessage::tree_id_size() const {
  return tree_id_.size();
}
inline void TextMessage::clear_tree_id() {
  tree_id_.Clear();
}
inline ::google::protobuf::uint32 TextMessage::tree_id(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.tree_id)
  return tree_id_.Get(index);
}
inline void TextMessage::set_tree_id(int index, ::google::protobuf::uint32 value) {
  tree_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.tree_id)
}
inline void TextMessage::add_tree_id(::google::protobuf::uint32 value) {
  tree_id_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.tree_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TextMessage::tree_id() const {
  // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.tree_id)
  return tree_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TextMessage::mutable_tree_id() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.tree_id)
  return &tree_id_;
}

// required string message = 5;
inline bool TextMessage::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TextMessage::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TextMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TextMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& TextMessage::message() const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.message)
}
inline void TextMessage::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.TextMessage.message)
}
inline void TextMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.TextMessage.message)
}
inline ::std::string* TextMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:MumbleProto.TextMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextMessage::release_message() {
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.TextMessage.message)
}

// -------------------------------------------------------------------

// PermissionDenied

// optional uint32 permission = 1;
inline bool PermissionDenied::has_permission() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PermissionDenied::set_has_permission() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PermissionDenied::clear_has_permission() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PermissionDenied::clear_permission() {
  permission_ = 0u;
  clear_has_permission();
}
inline ::google::protobuf::uint32 PermissionDenied::permission() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.permission)
  return permission_;
}
inline void PermissionDenied::set_permission(::google::protobuf::uint32 value) {
  set_has_permission();
  permission_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.permission)
}

// optional uint32 channel_id = 2;
inline bool PermissionDenied::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PermissionDenied::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PermissionDenied::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PermissionDenied::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 PermissionDenied::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.channel_id)
  return channel_id_;
}
inline void PermissionDenied::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.channel_id)
}

// optional uint32 session = 3;
inline bool PermissionDenied::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PermissionDenied::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PermissionDenied::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PermissionDenied::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 PermissionDenied::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.session)
  return session_;
}
inline void PermissionDenied::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.session)
}

// optional string reason = 4;
inline bool PermissionDenied::has_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PermissionDenied::set_has_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PermissionDenied::clear_has_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PermissionDenied::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& PermissionDenied::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.reason)
  return reason_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PermissionDenied::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.reason)
}
inline void PermissionDenied::set_reason(const char* value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.PermissionDenied.reason)
}
inline void PermissionDenied::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.PermissionDenied.reason)
}
inline ::std::string* PermissionDenied::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:MumbleProto.PermissionDenied.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PermissionDenied::release_reason() {
  clear_has_reason();
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PermissionDenied::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.PermissionDenied.reason)
}

// optional .MumbleProto.PermissionDenied.DenyType type = 5;
inline bool PermissionDenied::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PermissionDenied::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PermissionDenied::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PermissionDenied::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::MumbleProto::PermissionDenied_DenyType PermissionDenied::type() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.type)
  return static_cast< ::MumbleProto::PermissionDenied_DenyType >(type_);
}
inline void PermissionDenied::set_type(::MumbleProto::PermissionDenied_DenyType value) {
  assert(::MumbleProto::PermissionDenied_DenyType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.type)
}

// optional string name = 6;
inline bool PermissionDenied::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PermissionDenied::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PermissionDenied::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PermissionDenied::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& PermissionDenied::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PermissionDenied::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.name)
}
inline void PermissionDenied::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.PermissionDenied.name)
}
inline void PermissionDenied::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.PermissionDenied.name)
}
inline ::std::string* PermissionDenied::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MumbleProto.PermissionDenied.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PermissionDenied::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PermissionDenied::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.PermissionDenied.name)
}

// -------------------------------------------------------------------

// ACL_ChanGroup

// required string name = 1;
inline bool ACL_ChanGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ChanGroup::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ChanGroup::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ChanGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ACL_ChanGroup::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ACL_ChanGroup::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.name)
}
inline void ACL_ChanGroup::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ACL.ChanGroup.name)
}
inline void ACL_ChanGroup::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ACL.ChanGroup.name)
}
inline ::std::string* ACL_ChanGroup::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.ChanGroup.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ACL_ChanGroup::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ACL_ChanGroup::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ACL.ChanGroup.name)
}

// optional bool inherited = 2 [default = true];
inline bool ACL_ChanGroup::has_inherited() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ChanGroup::set_has_inherited() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ChanGroup::clear_has_inherited() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ChanGroup::clear_inherited() {
  inherited_ = true;
  clear_has_inherited();
}
inline bool ACL_ChanGroup::inherited() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherited)
  return inherited_;
}
inline void ACL_ChanGroup::set_inherited(bool value) {
  set_has_inherited();
  inherited_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherited)
}

// optional bool inherit = 3 [default = true];
inline bool ACL_ChanGroup::has_inherit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_ChanGroup::set_has_inherit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACL_ChanGroup::clear_has_inherit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACL_ChanGroup::clear_inherit() {
  inherit_ = true;
  clear_has_inherit();
}
inline bool ACL_ChanGroup::inherit() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherit)
  return inherit_;
}
inline void ACL_ChanGroup::set_inherit(bool value) {
  set_has_inherit();
  inherit_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherit)
}

// optional bool inheritable = 4 [default = true];
inline bool ACL_ChanGroup::has_inheritable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACL_ChanGroup::set_has_inheritable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACL_ChanGroup::clear_has_inheritable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACL_ChanGroup::clear_inheritable() {
  inheritable_ = true;
  clear_has_inheritable();
}
inline bool ACL_ChanGroup::inheritable() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inheritable)
  return inheritable_;
}
inline void ACL_ChanGroup::set_inheritable(bool value) {
  set_has_inheritable();
  inheritable_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inheritable)
}

// repeated uint32 add = 5;
inline int ACL_ChanGroup::add_size() const {
  return add_.size();
}
inline void ACL_ChanGroup::clear_add() {
  add_.Clear();
}
inline ::google::protobuf::uint32 ACL_ChanGroup::add(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.add)
  return add_.Get(index);
}
inline void ACL_ChanGroup::set_add(int index, ::google::protobuf::uint32 value) {
  add_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.add)
}
inline void ACL_ChanGroup::add_add(::google::protobuf::uint32 value) {
  add_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.add)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ACL_ChanGroup::add() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.add)
  return add_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ACL_ChanGroup::mutable_add() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.add)
  return &add_;
}

// repeated uint32 remove = 6;
inline int ACL_ChanGroup::remove_size() const {
  return remove_.size();
}
inline void ACL_ChanGroup::clear_remove() {
  remove_.Clear();
}
inline ::google::protobuf::uint32 ACL_ChanGroup::remove(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.remove)
  return remove_.Get(index);
}
inline void ACL_ChanGroup::set_remove(int index, ::google::protobuf::uint32 value) {
  remove_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.remove)
}
inline void ACL_ChanGroup::add_remove(::google::protobuf::uint32 value) {
  remove_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.remove)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ACL_ChanGroup::remove() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.remove)
  return remove_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ACL_ChanGroup::mutable_remove() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.remove)
  return &remove_;
}

// repeated uint32 inherited_members = 7;
inline int ACL_ChanGroup::inherited_members_size() const {
  return inherited_members_.size();
}
inline void ACL_ChanGroup::clear_inherited_members() {
  inherited_members_.Clear();
}
inline ::google::protobuf::uint32 ACL_ChanGroup::inherited_members(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherited_members)
  return inherited_members_.Get(index);
}
inline void ACL_ChanGroup::set_inherited_members(int index, ::google::protobuf::uint32 value) {
  inherited_members_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherited_members)
}
inline void ACL_ChanGroup::add_inherited_members(::google::protobuf::uint32 value) {
  inherited_members_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.inherited_members)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ACL_ChanGroup::inherited_members() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.inherited_members)
  return inherited_members_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ACL_ChanGroup::mutable_inherited_members() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.inherited_members)
  return &inherited_members_;
}

// -------------------------------------------------------------------

// ACL_ChanACL

// optional bool apply_here = 1 [default = true];
inline bool ACL_ChanACL::has_apply_here() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ChanACL::set_has_apply_here() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ChanACL::clear_has_apply_here() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ChanACL::clear_apply_here() {
  apply_here_ = true;
  clear_has_apply_here();
}
inline bool ACL_ChanACL::apply_here() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.apply_here)
  return apply_here_;
}
inline void ACL_ChanACL::set_apply_here(bool value) {
  set_has_apply_here();
  apply_here_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.apply_here)
}

// optional bool apply_subs = 2 [default = true];
inline bool ACL_ChanACL::has_apply_subs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ChanACL::set_has_apply_subs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ChanACL::clear_has_apply_subs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ChanACL::clear_apply_subs() {
  apply_subs_ = true;
  clear_has_apply_subs();
}
inline bool ACL_ChanACL::apply_subs() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.apply_subs)
  return apply_subs_;
}
inline void ACL_ChanACL::set_apply_subs(bool value) {
  set_has_apply_subs();
  apply_subs_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.apply_subs)
}

// optional bool inherited = 3 [default = true];
inline bool ACL_ChanACL::has_inherited() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_ChanACL::set_has_inherited() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACL_ChanACL::clear_has_inherited() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACL_ChanACL::clear_inherited() {
  inherited_ = true;
  clear_has_inherited();
}
inline bool ACL_ChanACL::inherited() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.inherited)
  return inherited_;
}
inline void ACL_ChanACL::set_inherited(bool value) {
  set_has_inherited();
  inherited_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.inherited)
}

// optional uint32 user_id = 4;
inline bool ACL_ChanACL::has_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACL_ChanACL::set_has_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACL_ChanACL::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACL_ChanACL::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ACL_ChanACL::user_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.user_id)
  return user_id_;
}
inline void ACL_ChanACL::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.user_id)
}

// optional string group = 5;
inline bool ACL_ChanACL::has_group() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACL_ChanACL::set_has_group() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACL_ChanACL::clear_has_group() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACL_ChanACL::clear_group() {
  group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_group();
}
inline const ::std::string& ACL_ChanACL::group() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.group)
  return group_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ACL_ChanACL::set_group(const ::std::string& value) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.group)
}
inline void ACL_ChanACL::set_group(const char* value) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ACL.ChanACL.group)
}
inline void ACL_ChanACL::set_group(const char* value, size_t size) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ACL.ChanACL.group)
}
inline ::std::string* ACL_ChanACL::mutable_group() {
  set_has_group();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.ChanACL.group)
  return group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ACL_ChanACL::release_group() {
  clear_has_group();
  return group_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ACL_ChanACL::set_allocated_group(::std::string* group) {
  if (group != NULL) {
    set_has_group();
  } else {
    clear_has_group();
  }
  group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ACL.ChanACL.group)
}

// optional uint32 grant = 6;
inline bool ACL_ChanACL::has_grant() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACL_ChanACL::set_has_grant() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACL_ChanACL::clear_has_grant() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACL_ChanACL::clear_grant() {
  grant_ = 0u;
  clear_has_grant();
}
inline ::google::protobuf::uint32 ACL_ChanACL::grant() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.grant)
  return grant_;
}
inline void ACL_ChanACL::set_grant(::google::protobuf::uint32 value) {
  set_has_grant();
  grant_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.grant)
}

// optional uint32 deny = 7;
inline bool ACL_ChanACL::has_deny() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACL_ChanACL::set_has_deny() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACL_ChanACL::clear_has_deny() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACL_ChanACL::clear_deny() {
  deny_ = 0u;
  clear_has_deny();
}
inline ::google::protobuf::uint32 ACL_ChanACL::deny() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.deny)
  return deny_;
}
inline void ACL_ChanACL::set_deny(::google::protobuf::uint32 value) {
  set_has_deny();
  deny_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.deny)
}

// -------------------------------------------------------------------

// ACL

// required uint32 channel_id = 1;
inline bool ACL::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 ACL::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.channel_id)
  return channel_id_;
}
inline void ACL::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.channel_id)
}

// optional bool inherit_acls = 2 [default = true];
inline bool ACL::has_inherit_acls() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL::set_has_inherit_acls() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL::clear_has_inherit_acls() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL::clear_inherit_acls() {
  inherit_acls_ = true;
  clear_has_inherit_acls();
}
inline bool ACL::inherit_acls() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.inherit_acls)
  return inherit_acls_;
}
inline void ACL::set_inherit_acls(bool value) {
  set_has_inherit_acls();
  inherit_acls_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.inherit_acls)
}

// repeated .MumbleProto.ACL.ChanGroup groups = 3;
inline int ACL::groups_size() const {
  return groups_.size();
}
inline void ACL::clear_groups() {
  groups_.Clear();
}
inline const ::MumbleProto::ACL_ChanGroup& ACL::groups(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.groups)
  return groups_.Get(index);
}
inline ::MumbleProto::ACL_ChanGroup* ACL::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.groups)
  return groups_.Mutable(index);
}
inline ::MumbleProto::ACL_ChanGroup* ACL::add_groups() {
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.groups)
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
ACL::groups() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.groups)
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
ACL::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.groups)
  return &groups_;
}

// repeated .MumbleProto.ACL.ChanACL acls = 4;
inline int ACL::acls_size() const {
  return acls_.size();
}
inline void ACL::clear_acls() {
  acls_.Clear();
}
inline const ::MumbleProto::ACL_ChanACL& ACL::acls(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.acls)
  return acls_.Get(index);
}
inline ::MumbleProto::ACL_ChanACL* ACL::mutable_acls(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.acls)
  return acls_.Mutable(index);
}
inline ::MumbleProto::ACL_ChanACL* ACL::add_acls() {
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.acls)
  return acls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
ACL::acls() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.acls)
  return acls_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
ACL::mutable_acls() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.acls)
  return &acls_;
}

// optional bool query = 5 [default = false];
inline bool ACL::has_query() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACL::set_has_query() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACL::clear_has_query() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACL::clear_query() {
  query_ = false;
  clear_has_query();
}
inline bool ACL::query() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.query)
  return query_;
}
inline void ACL::set_query(bool value) {
  set_has_query();
  query_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.query)
}

// -------------------------------------------------------------------

// QueryUsers

// repeated uint32 ids = 1;
inline int QueryUsers::ids_size() const {
  return ids_.size();
}
inline void QueryUsers::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::uint32 QueryUsers::ids(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.QueryUsers.ids)
  return ids_.Get(index);
}
inline void QueryUsers::set_ids(int index, ::google::protobuf::uint32 value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.ids)
}
inline void QueryUsers::add_ids(::google::protobuf::uint32 value) {
  ids_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
QueryUsers::ids() const {
  // @@protoc_insertion_point(field_list:MumbleProto.QueryUsers.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
QueryUsers::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.QueryUsers.ids)
  return &ids_;
}

// repeated string names = 2;
inline int QueryUsers::names_size() const {
  return names_.size();
}
inline void QueryUsers::clear_names() {
  names_.Clear();
}
inline const ::std::string& QueryUsers::names(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.QueryUsers.names)
  return names_.Get(index);
}
inline ::std::string* QueryUsers::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.QueryUsers.names)
  return names_.Mutable(index);
}
inline void QueryUsers::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.names)
  names_.Mutable(index)->assign(value);
}
inline void QueryUsers::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MumbleProto.QueryUsers.names)
}
inline void QueryUsers::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.QueryUsers.names)
}
inline ::std::string* QueryUsers::add_names() {
  return names_.Add();
}
inline void QueryUsers::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.names)
}
inline void QueryUsers::add_names(const char* value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MumbleProto.QueryUsers.names)
}
inline void QueryUsers::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MumbleProto.QueryUsers.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
QueryUsers::names() const {
  // @@protoc_insertion_point(field_list:MumbleProto.QueryUsers.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
QueryUsers::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.QueryUsers.names)
  return &names_;
}

// -------------------------------------------------------------------

// CryptSetup

// optional bytes key = 1;
inline bool CryptSetup::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CryptSetup::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CryptSetup::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CryptSetup::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& CryptSetup::key() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptSetup::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.key)
}
inline void CryptSetup::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.key)
}
inline void CryptSetup::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.key)
}
inline ::std::string* CryptSetup::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CryptSetup::release_key() {
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptSetup::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.key)
}

// optional bytes client_nonce = 2;
inline bool CryptSetup::has_client_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CryptSetup::set_has_client_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CryptSetup::clear_has_client_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CryptSetup::clear_client_nonce() {
  client_nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_nonce();
}
inline const ::std::string& CryptSetup::client_nonce() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.client_nonce)
  return client_nonce_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptSetup::set_client_nonce(const ::std::string& value) {
  set_has_client_nonce();
  client_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.client_nonce)
}
inline void CryptSetup::set_client_nonce(const char* value) {
  set_has_client_nonce();
  client_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.client_nonce)
}
inline void CryptSetup::set_client_nonce(const void* value, size_t size) {
  set_has_client_nonce();
  client_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.client_nonce)
}
inline ::std::string* CryptSetup::mutable_client_nonce() {
  set_has_client_nonce();
  // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.client_nonce)
  return client_nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CryptSetup::release_client_nonce() {
  clear_has_client_nonce();
  return client_nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptSetup::set_allocated_client_nonce(::std::string* client_nonce) {
  if (client_nonce != NULL) {
    set_has_client_nonce();
  } else {
    clear_has_client_nonce();
  }
  client_nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_nonce);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.client_nonce)
}

// optional bytes server_nonce = 3;
inline bool CryptSetup::has_server_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CryptSetup::set_has_server_nonce() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CryptSetup::clear_has_server_nonce() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CryptSetup::clear_server_nonce() {
  server_nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_nonce();
}
inline const ::std::string& CryptSetup::server_nonce() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.server_nonce)
  return server_nonce_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptSetup::set_server_nonce(const ::std::string& value) {
  set_has_server_nonce();
  server_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.server_nonce)
}
inline void CryptSetup::set_server_nonce(const char* value) {
  set_has_server_nonce();
  server_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.server_nonce)
}
inline void CryptSetup::set_server_nonce(const void* value, size_t size) {
  set_has_server_nonce();
  server_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.server_nonce)
}
inline ::std::string* CryptSetup::mutable_server_nonce() {
  set_has_server_nonce();
  // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.server_nonce)
  return server_nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CryptSetup::release_server_nonce() {
  clear_has_server_nonce();
  return server_nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptSetup::set_allocated_server_nonce(::std::string* server_nonce) {
  if (server_nonce != NULL) {
    set_has_server_nonce();
  } else {
    clear_has_server_nonce();
  }
  server_nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_nonce);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.server_nonce)
}

// -------------------------------------------------------------------

// ContextActionModify

// required string action = 1;
inline bool ContextActionModify::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContextActionModify::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContextActionModify::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContextActionModify::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_action();
}
inline const ::std::string& ContextActionModify::action() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.action)
  return action_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextActionModify::set_action(const ::std::string& value) {
  set_has_action();
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.action)
}
inline void ContextActionModify::set_action(const char* value) {
  set_has_action();
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ContextActionModify.action)
}
inline void ContextActionModify::set_action(const char* value, size_t size) {
  set_has_action();
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextActionModify.action)
}
inline ::std::string* ContextActionModify::mutable_action() {
  set_has_action();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ContextActionModify.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContextActionModify::release_action() {
  clear_has_action();
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextActionModify::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    set_has_action();
  } else {
    clear_has_action();
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextActionModify.action)
}

// optional string text = 2;
inline bool ContextActionModify::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContextActionModify::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContextActionModify::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContextActionModify::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& ContextActionModify::text() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextActionModify::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.text)
}
inline void ContextActionModify::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ContextActionModify.text)
}
inline void ContextActionModify::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextActionModify.text)
}
inline ::std::string* ContextActionModify::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ContextActionModify.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContextActionModify::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextActionModify::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextActionModify.text)
}

// optional uint32 context = 3;
inline bool ContextActionModify::has_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContextActionModify::set_has_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContextActionModify::clear_has_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContextActionModify::clear_context() {
  context_ = 0u;
  clear_has_context();
}
inline ::google::protobuf::uint32 ContextActionModify::context() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.context)
  return context_;
}
inline void ContextActionModify::set_context(::google::protobuf::uint32 value) {
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.context)
}

// optional .MumbleProto.ContextActionModify.Operation operation = 4;
inline bool ContextActionModify::has_operation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContextActionModify::set_has_operation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContextActionModify::clear_has_operation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContextActionModify::clear_operation() {
  operation_ = 0;
  clear_has_operation();
}
inline ::MumbleProto::ContextActionModify_Operation ContextActionModify::operation() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.operation)
  return static_cast< ::MumbleProto::ContextActionModify_Operation >(operation_);
}
inline void ContextActionModify::set_operation(::MumbleProto::ContextActionModify_Operation value) {
  assert(::MumbleProto::ContextActionModify_Operation_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.operation)
}

// -------------------------------------------------------------------

// ContextAction

// optional uint32 session = 1;
inline bool ContextAction::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContextAction::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContextAction::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContextAction::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 ContextAction::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.session)
  return session_;
}
inline void ContextAction::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.session)
}

// optional uint32 channel_id = 2;
inline bool ContextAction::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContextAction::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContextAction::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContextAction::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 ContextAction::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.channel_id)
  return channel_id_;
}
inline void ContextAction::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.channel_id)
}

// required string action = 3;
inline bool ContextAction::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContextAction::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContextAction::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContextAction::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_action();
}
inline const ::std::string& ContextAction::action() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.action)
  return action_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextAction::set_action(const ::std::string& value) {
  set_has_action();
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.action)
}
inline void ContextAction::set_action(const char* value) {
  set_has_action();
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ContextAction.action)
}
inline void ContextAction::set_action(const char* value, size_t size) {
  set_has_action();
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextAction.action)
}
inline ::std::string* ContextAction::mutable_action() {
  set_has_action();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ContextAction.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContextAction::release_action() {
  clear_has_action();
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextAction::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    set_has_action();
  } else {
    clear_has_action();
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextAction.action)
}

// -------------------------------------------------------------------

// UserList_User

// required uint32 user_id = 1;
inline bool UserList_User::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserList_User::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserList_User::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserList_User::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserList_User::user_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.user_id)
  return user_id_;
}
inline void UserList_User::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.user_id)
}

// optional string name = 2;
inline bool UserList_User::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserList_User::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserList_User::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserList_User::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& UserList_User::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserList_User::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.name)
}
inline void UserList_User::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserList.User.name)
}
inline void UserList_User::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserList.User.name)
}
inline ::std::string* UserList_User::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.User.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserList_User::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserList_User::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserList.User.name)
}

// optional string last_seen = 3;
inline bool UserList_User::has_last_seen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserList_User::set_has_last_seen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserList_User::clear_has_last_seen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserList_User::clear_last_seen() {
  last_seen_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_last_seen();
}
inline const ::std::string& UserList_User::last_seen() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.last_seen)
  return last_seen_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserList_User::set_last_seen(const ::std::string& value) {
  set_has_last_seen();
  last_seen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.last_seen)
}
inline void UserList_User::set_last_seen(const char* value) {
  set_has_last_seen();
  last_seen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserList.User.last_seen)
}
inline void UserList_User::set_last_seen(const char* value, size_t size) {
  set_has_last_seen();
  last_seen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserList.User.last_seen)
}
inline ::std::string* UserList_User::mutable_last_seen() {
  set_has_last_seen();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.User.last_seen)
  return last_seen_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserList_User::release_last_seen() {
  clear_has_last_seen();
  return last_seen_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserList_User::set_allocated_last_seen(::std::string* last_seen) {
  if (last_seen != NULL) {
    set_has_last_seen();
  } else {
    clear_has_last_seen();
  }
  last_seen_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_seen);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserList.User.last_seen)
}

// optional uint32 last_channel = 4;
inline bool UserList_User::has_last_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserList_User::set_has_last_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserList_User::clear_has_last_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserList_User::clear_last_channel() {
  last_channel_ = 0u;
  clear_has_last_channel();
}
inline ::google::protobuf::uint32 UserList_User::last_channel() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.last_channel)
  return last_channel_;
}
inline void UserList_User::set_last_channel(::google::protobuf::uint32 value) {
  set_has_last_channel();
  last_channel_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.last_channel)
}

// -------------------------------------------------------------------

// UserList

// repeated .MumbleProto.UserList.User users = 1;
inline int UserList::users_size() const {
  return users_.size();
}
inline void UserList::clear_users() {
  users_.Clear();
}
inline const ::MumbleProto::UserList_User& UserList::users(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.users)
  return users_.Get(index);
}
inline ::MumbleProto::UserList_User* UserList::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.users)
  return users_.Mutable(index);
}
inline ::MumbleProto::UserList_User* UserList::add_users() {
  // @@protoc_insertion_point(field_add:MumbleProto.UserList.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >&
UserList::users() const {
  // @@protoc_insertion_point(field_list:MumbleProto.UserList.users)
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >*
UserList::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserList.users)
  return &users_;
}

// -------------------------------------------------------------------

// VoiceTarget_Target

// repeated uint32 session = 1;
inline int VoiceTarget_Target::session_size() const {
  return session_.size();
}
inline void VoiceTarget_Target::clear_session() {
  session_.Clear();
}
inline ::google::protobuf::uint32 VoiceTarget_Target::session(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.session)
  return session_.Get(index);
}
inline void VoiceTarget_Target::set_session(int index, ::google::protobuf::uint32 value) {
  session_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.session)
}
inline void VoiceTarget_Target::add_session(::google::protobuf::uint32 value) {
  session_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.VoiceTarget.Target.session)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VoiceTarget_Target::session() const {
  // @@protoc_insertion_point(field_list:MumbleProto.VoiceTarget.Target.session)
  return session_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VoiceTarget_Target::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.VoiceTarget.Target.session)
  return &session_;
}

// optional uint32 channel_id = 2;
inline bool VoiceTarget_Target::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoiceTarget_Target::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VoiceTarget_Target::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VoiceTarget_Target::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 VoiceTarget_Target::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.channel_id)
  return channel_id_;
}
inline void VoiceTarget_Target::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.channel_id)
}

// optional string group = 3;
inline bool VoiceTarget_Target::has_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoiceTarget_Target::set_has_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VoiceTarget_Target::clear_has_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VoiceTarget_Target::clear_group() {
  group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_group();
}
inline const ::std::string& VoiceTarget_Target::group() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.group)
  return group_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VoiceTarget_Target::set_group(const ::std::string& value) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.group)
}
inline void VoiceTarget_Target::set_group(const char* value) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.VoiceTarget.Target.group)
}
inline void VoiceTarget_Target::set_group(const char* value, size_t size) {
  set_has_group();
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.VoiceTarget.Target.group)
}
inline ::std::string* VoiceTarget_Target::mutable_group() {
  set_has_group();
  // @@protoc_insertion_point(field_mutable:MumbleProto.VoiceTarget.Target.group)
  return group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VoiceTarget_Target::release_group() {
  clear_has_group();
  return group_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VoiceTarget_Target::set_allocated_group(::std::string* group) {
  if (group != NULL) {
    set_has_group();
  } else {
    clear_has_group();
  }
  group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.VoiceTarget.Target.group)
}

// optional bool links = 4 [default = false];
inline bool VoiceTarget_Target::has_links() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VoiceTarget_Target::set_has_links() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VoiceTarget_Target::clear_has_links() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VoiceTarget_Target::clear_links() {
  links_ = false;
  clear_has_links();
}
inline bool VoiceTarget_Target::links() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.links)
  return links_;
}
inline void VoiceTarget_Target::set_links(bool value) {
  set_has_links();
  links_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.links)
}

// optional bool children = 5 [default = false];
inline bool VoiceTarget_Target::has_children() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VoiceTarget_Target::set_has_children() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VoiceTarget_Target::clear_has_children() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VoiceTarget_Target::clear_children() {
  children_ = false;
  clear_has_children();
}
inline bool VoiceTarget_Target::children() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.children)
  return children_;
}
inline void VoiceTarget_Target::set_children(bool value) {
  set_has_children();
  children_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.children)
}

// -------------------------------------------------------------------

// VoiceTarget

// optional uint32 id = 1;
inline bool VoiceTarget::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoiceTarget::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VoiceTarget::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VoiceTarget::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 VoiceTarget::id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.id)
  return id_;
}
inline void VoiceTarget::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.id)
}

// repeated .MumbleProto.VoiceTarget.Target targets = 2;
inline int VoiceTarget::targets_size() const {
  return targets_.size();
}
inline void VoiceTarget::clear_targets() {
  targets_.Clear();
}
inline const ::MumbleProto::VoiceTarget_Target& VoiceTarget::targets(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.targets)
  return targets_.Get(index);
}
inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.VoiceTarget.targets)
  return targets_.Mutable(index);
}
inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::add_targets() {
  // @@protoc_insertion_point(field_add:MumbleProto.VoiceTarget.targets)
  return targets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
VoiceTarget::targets() const {
  // @@protoc_insertion_point(field_list:MumbleProto.VoiceTarget.targets)
  return targets_;
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
VoiceTarget::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.VoiceTarget.targets)
  return &targets_;
}

// -------------------------------------------------------------------

// PermissionQuery

// optional uint32 channel_id = 1;
inline bool PermissionQuery::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PermissionQuery::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PermissionQuery::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PermissionQuery::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 PermissionQuery::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.channel_id)
  return channel_id_;
}
inline void PermissionQuery::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.channel_id)
}

// optional uint32 permissions = 2;
inline bool PermissionQuery::has_permissions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PermissionQuery::set_has_permissions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PermissionQuery::clear_has_permissions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PermissionQuery::clear_permissions() {
  permissions_ = 0u;
  clear_has_permissions();
}
inline ::google::protobuf::uint32 PermissionQuery::permissions() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.permissions)
  return permissions_;
}
inline void PermissionQuery::set_permissions(::google::protobuf::uint32 value) {
  set_has_permissions();
  permissions_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.permissions)
}

// optional bool flush = 3 [default = false];
inline bool PermissionQuery::has_flush() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PermissionQuery::set_has_flush() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PermissionQuery::clear_has_flush() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PermissionQuery::clear_flush() {
  flush_ = false;
  clear_has_flush();
}
inline bool PermissionQuery::flush() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.flush)
  return flush_;
}
inline void PermissionQuery::set_flush(bool value) {
  set_has_flush();
  flush_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.flush)
}

// -------------------------------------------------------------------

// CodecVersion

// required int32 alpha = 1;
inline bool CodecVersion::has_alpha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CodecVersion::set_has_alpha() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CodecVersion::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CodecVersion::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline ::google::protobuf::int32 CodecVersion::alpha() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.alpha)
  return alpha_;
}
inline void CodecVersion::set_alpha(::google::protobuf::int32 value) {
  set_has_alpha();
  alpha_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.alpha)
}

// required int32 beta = 2;
inline bool CodecVersion::has_beta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CodecVersion::set_has_beta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CodecVersion::clear_has_beta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CodecVersion::clear_beta() {
  beta_ = 0;
  clear_has_beta();
}
inline ::google::protobuf::int32 CodecVersion::beta() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.beta)
  return beta_;
}
inline void CodecVersion::set_beta(::google::protobuf::int32 value) {
  set_has_beta();
  beta_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.beta)
}

// required bool prefer_alpha = 3 [default = true];
inline bool CodecVersion::has_prefer_alpha() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CodecVersion::set_has_prefer_alpha() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CodecVersion::clear_has_prefer_alpha() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CodecVersion::clear_prefer_alpha() {
  prefer_alpha_ = true;
  clear_has_prefer_alpha();
}
inline bool CodecVersion::prefer_alpha() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.prefer_alpha)
  return prefer_alpha_;
}
inline void CodecVersion::set_prefer_alpha(bool value) {
  set_has_prefer_alpha();
  prefer_alpha_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.prefer_alpha)
}

// optional bool opus = 4 [default = false];
inline bool CodecVersion::has_opus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CodecVersion::set_has_opus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CodecVersion::clear_has_opus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CodecVersion::clear_opus() {
  opus_ = false;
  clear_has_opus();
}
inline bool CodecVersion::opus() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.opus)
  return opus_;
}
inline void CodecVersion::set_opus(bool value) {
  set_has_opus();
  opus_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.opus)
}

// -------------------------------------------------------------------

// UserStats_Stats

// optional uint32 good = 1;
inline bool UserStats_Stats::has_good() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStats_Stats::set_has_good() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStats_Stats::clear_has_good() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStats_Stats::clear_good() {
  good_ = 0u;
  clear_has_good();
}
inline ::google::protobuf::uint32 UserStats_Stats::good() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.good)
  return good_;
}
inline void UserStats_Stats::set_good(::google::protobuf::uint32 value) {
  set_has_good();
  good_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.good)
}

// optional uint32 late = 2;
inline bool UserStats_Stats::has_late() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStats_Stats::set_has_late() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStats_Stats::clear_has_late() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStats_Stats::clear_late() {
  late_ = 0u;
  clear_has_late();
}
inline ::google::protobuf::uint32 UserStats_Stats::late() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.late)
  return late_;
}
inline void UserStats_Stats::set_late(::google::protobuf::uint32 value) {
  set_has_late();
  late_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.late)
}

// optional uint32 lost = 3;
inline bool UserStats_Stats::has_lost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStats_Stats::set_has_lost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStats_Stats::clear_has_lost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStats_Stats::clear_lost() {
  lost_ = 0u;
  clear_has_lost();
}
inline ::google::protobuf::uint32 UserStats_Stats::lost() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.lost)
  return lost_;
}
inline void UserStats_Stats::set_lost(::google::protobuf::uint32 value) {
  set_has_lost();
  lost_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.lost)
}

// optional uint32 resync = 4;
inline bool UserStats_Stats::has_resync() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStats_Stats::set_has_resync() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStats_Stats::clear_has_resync() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStats_Stats::clear_resync() {
  resync_ = 0u;
  clear_has_resync();
}
inline ::google::protobuf::uint32 UserStats_Stats::resync() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.resync)
  return resync_;
}
inline void UserStats_Stats::set_resync(::google::protobuf::uint32 value) {
  set_has_resync();
  resync_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.resync)
}

// -------------------------------------------------------------------

// UserStats

// optional uint32 session = 1;
inline bool UserStats::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStats::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStats::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStats::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 UserStats::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.session)
  return session_;
}
inline void UserStats::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.session)
}

// optional bool stats_only = 2 [default = false];
inline bool UserStats::has_stats_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStats::set_has_stats_only() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStats::clear_has_stats_only() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStats::clear_stats_only() {
  stats_only_ = false;
  clear_has_stats_only();
}
inline bool UserStats::stats_only() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.stats_only)
  return stats_only_;
}
inline void UserStats::set_stats_only(bool value) {
  set_has_stats_only();
  stats_only_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.stats_only)
}

// repeated bytes certificates = 3;
inline int UserStats::certificates_size() const {
  return certificates_.size();
}
inline void UserStats::clear_certificates() {
  certificates_.Clear();
}
inline const ::std::string& UserStats::certificates(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.certificates)
  return certificates_.Get(index);
}
inline ::std::string* UserStats::mutable_certificates(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.certificates)
  return certificates_.Mutable(index);
}
inline void UserStats::set_certificates(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.certificates)
  certificates_.Mutable(index)->assign(value);
}
inline void UserStats::set_certificates(int index, const char* value) {
  certificates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserStats.certificates)
}
inline void UserStats::set_certificates(int index, const void* value, size_t size) {
  certificates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserStats.certificates)
}
inline ::std::string* UserStats::add_certificates() {
  return certificates_.Add();
}
inline void UserStats::add_certificates(const ::std::string& value) {
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MumbleProto.UserStats.certificates)
}
inline void UserStats::add_certificates(const char* value) {
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MumbleProto.UserStats.certificates)
}
inline void UserStats::add_certificates(const void* value, size_t size) {
  certificates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MumbleProto.UserStats.certificates)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserStats::certificates() const {
  // @@protoc_insertion_point(field_list:MumbleProto.UserStats.certificates)
  return certificates_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserStats::mutable_certificates() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserStats.certificates)
  return &certificates_;
}

// optional .MumbleProto.UserStats.Stats from_client = 4;
inline bool UserStats::has_from_client() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStats::set_has_from_client() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStats::clear_has_from_client() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStats::clear_from_client() {
  if (from_client_ != NULL) from_client_->::MumbleProto::UserStats_Stats::Clear();
  clear_has_from_client();
}
inline const ::MumbleProto::UserStats_Stats& UserStats::from_client() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.from_client)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return from_client_ != NULL ? *from_client_ : *default_instance().from_client_;
#else
  return from_client_ != NULL ? *from_client_ : *default_instance_->from_client_;
#endif
}
inline ::MumbleProto::UserStats_Stats* UserStats::mutable_from_client() {
  set_has_from_client();
  if (from_client_ == NULL) {
    from_client_ = new ::MumbleProto::UserStats_Stats;
  }
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.from_client)
  return from_client_;
}
inline ::MumbleProto::UserStats_Stats* UserStats::release_from_client() {
  clear_has_from_client();
  ::MumbleProto::UserStats_Stats* temp = from_client_;
  from_client_ = NULL;
  return temp;
}
inline void UserStats::set_allocated_from_client(::MumbleProto::UserStats_Stats* from_client) {
  delete from_client_;
  from_client_ = from_client;
  if (from_client) {
    set_has_from_client();
  } else {
    clear_has_from_client();
  }
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.from_client)
}

// optional .MumbleProto.UserStats.Stats from_server = 5;
inline bool UserStats::has_from_server() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserStats::set_has_from_server() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserStats::clear_has_from_server() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserStats::clear_from_server() {
  if (from_server_ != NULL) from_server_->::MumbleProto::UserStats_Stats::Clear();
  clear_has_from_server();
}
inline const ::MumbleProto::UserStats_Stats& UserStats::from_server() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.from_server)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return from_server_ != NULL ? *from_server_ : *default_instance().from_server_;
#else
  return from_server_ != NULL ? *from_server_ : *default_instance_->from_server_;
#endif
}
inline ::MumbleProto::UserStats_Stats* UserStats::mutable_from_server() {
  set_has_from_server();
  if (from_server_ == NULL) {
    from_server_ = new ::MumbleProto::UserStats_Stats;
  }
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.from_server)
  return from_server_;
}
inline ::MumbleProto::UserStats_Stats* UserStats::release_from_server() {
  clear_has_from_server();
  ::MumbleProto::UserStats_Stats* temp = from_server_;
  from_server_ = NULL;
  return temp;
}
inline void UserStats::set_allocated_from_server(::MumbleProto::UserStats_Stats* from_server) {
  delete from_server_;
  from_server_ = from_server;
  if (from_server) {
    set_has_from_server();
  } else {
    clear_has_from_server();
  }
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.from_server)
}

// optional uint32 udp_packets = 6;
inline bool UserStats::has_udp_packets() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserStats::set_has_udp_packets() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserStats::clear_has_udp_packets() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserStats::clear_udp_packets() {
  udp_packets_ = 0u;
  clear_has_udp_packets();
}
inline ::google::protobuf::uint32 UserStats::udp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_packets)
  return udp_packets_;
}
inline void UserStats::set_udp_packets(::google::protobuf::uint32 value) {
  set_has_udp_packets();
  udp_packets_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_packets)
}

// optional uint32 tcp_packets = 7;
inline bool UserStats::has_tcp_packets() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserStats::set_has_tcp_packets() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserStats::clear_has_tcp_packets() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserStats::clear_tcp_packets() {
  tcp_packets_ = 0u;
  clear_has_tcp_packets();
}
inline ::google::protobuf::uint32 UserStats::tcp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_packets)
  return tcp_packets_;
}
inline void UserStats::set_tcp_packets(::google::protobuf::uint32 value) {
  set_has_tcp_packets();
  tcp_packets_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_packets)
}

// optional float udp_ping_avg = 8;
inline bool UserStats::has_udp_ping_avg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserStats::set_has_udp_ping_avg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserStats::clear_has_udp_ping_avg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserStats::clear_udp_ping_avg() {
  udp_ping_avg_ = 0;
  clear_has_udp_ping_avg();
}
inline float UserStats::udp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_ping_avg)
  return udp_ping_avg_;
}
inline void UserStats::set_udp_ping_avg(float value) {
  set_has_udp_ping_avg();
  udp_ping_avg_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_ping_avg)
}

// optional float udp_ping_var = 9;
inline bool UserStats::has_udp_ping_var() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserStats::set_has_udp_ping_var() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserStats::clear_has_udp_ping_var() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserStats::clear_udp_ping_var() {
  udp_ping_var_ = 0;
  clear_has_udp_ping_var();
}
inline float UserStats::udp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_ping_var)
  return udp_ping_var_;
}
inline void UserStats::set_udp_ping_var(float value) {
  set_has_udp_ping_var();
  udp_ping_var_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_ping_var)
}

// optional float tcp_ping_avg = 10;
inline bool UserStats::has_tcp_ping_avg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserStats::set_has_tcp_ping_avg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserStats::clear_has_tcp_ping_avg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserStats::clear_tcp_ping_avg() {
  tcp_ping_avg_ = 0;
  clear_has_tcp_ping_avg();
}
inline float UserStats::tcp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_ping_avg)
  return tcp_ping_avg_;
}
inline void UserStats::set_tcp_ping_avg(float value) {
  set_has_tcp_ping_avg();
  tcp_ping_avg_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_ping_avg)
}

// optional float tcp_ping_var = 11;
inline bool UserStats::has_tcp_ping_var() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserStats::set_has_tcp_ping_var() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserStats::clear_has_tcp_ping_var() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserStats::clear_tcp_ping_var() {
  tcp_ping_var_ = 0;
  clear_has_tcp_ping_var();
}
inline float UserStats::tcp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_ping_var)
  return tcp_ping_var_;
}
inline void UserStats::set_tcp_ping_var(float value) {
  set_has_tcp_ping_var();
  tcp_ping_var_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_ping_var)
}

// optional .MumbleProto.Version version = 12;
inline bool UserStats::has_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserStats::set_has_version() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserStats::clear_has_version() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserStats::clear_version() {
  if (version_ != NULL) version_->::MumbleProto::Version::Clear();
  clear_has_version();
}
inline const ::MumbleProto::Version& UserStats::version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.version)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return version_ != NULL ? *version_ : *default_instance().version_;
#else
  return version_ != NULL ? *version_ : *default_instance_->version_;
#endif
}
inline ::MumbleProto::Version* UserStats::mutable_version() {
  set_has_version();
  if (version_ == NULL) {
    version_ = new ::MumbleProto::Version;
  }
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.version)
  return version_;
}
inline ::MumbleProto::Version* UserStats::release_version() {
  clear_has_version();
  ::MumbleProto::Version* temp = version_;
  version_ = NULL;
  return temp;
}
inline void UserStats::set_allocated_version(::MumbleProto::Version* version) {
  delete version_;
  version_ = version;
  if (version) {
    set_has_version();
  } else {
    clear_has_version();
  }
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.version)
}

// repeated int32 celt_versions = 13;
inline int UserStats::celt_versions_size() const {
  return celt_versions_.size();
}
inline void UserStats::clear_celt_versions() {
  celt_versions_.Clear();
}
inline ::google::protobuf::int32 UserStats::celt_versions(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.celt_versions)
  return celt_versions_.Get(index);
}
inline void UserStats::set_celt_versions(int index, ::google::protobuf::int32 value) {
  celt_versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.celt_versions)
}
inline void UserStats::add_celt_versions(::google::protobuf::int32 value) {
  celt_versions_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.UserStats.celt_versions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UserStats::celt_versions() const {
  // @@protoc_insertion_point(field_list:MumbleProto.UserStats.celt_versions)
  return celt_versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UserStats::mutable_celt_versions() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserStats.celt_versions)
  return &celt_versions_;
}

// optional bytes address = 14;
inline bool UserStats::has_address() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserStats::set_has_address() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserStats::clear_has_address() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserStats::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& UserStats::address() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.address)
  return address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserStats::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.address)
}
inline void UserStats::set_address(const char* value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserStats.address)
}
inline void UserStats::set_address(const void* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserStats.address)
}
inline ::std::string* UserStats::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserStats::release_address() {
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserStats::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.address)
}

// optional uint32 bandwidth = 15;
inline bool UserStats::has_bandwidth() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserStats::set_has_bandwidth() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserStats::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserStats::clear_bandwidth() {
  bandwidth_ = 0u;
  clear_has_bandwidth();
}
inline ::google::protobuf::uint32 UserStats::bandwidth() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.bandwidth)
  return bandwidth_;
}
inline void UserStats::set_bandwidth(::google::protobuf::uint32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.bandwidth)
}

// optional uint32 onlinesecs = 16;
inline bool UserStats::has_onlinesecs() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserStats::set_has_onlinesecs() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserStats::clear_has_onlinesecs() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserStats::clear_onlinesecs() {
  onlinesecs_ = 0u;
  clear_has_onlinesecs();
}
inline ::google::protobuf::uint32 UserStats::onlinesecs() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.onlinesecs)
  return onlinesecs_;
}
inline void UserStats::set_onlinesecs(::google::protobuf::uint32 value) {
  set_has_onlinesecs();
  onlinesecs_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.onlinesecs)
}

// optional uint32 idlesecs = 17;
inline bool UserStats::has_idlesecs() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserStats::set_has_idlesecs() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserStats::clear_has_idlesecs() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserStats::clear_idlesecs() {
  idlesecs_ = 0u;
  clear_has_idlesecs();
}
inline ::google::protobuf::uint32 UserStats::idlesecs() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.idlesecs)
  return idlesecs_;
}
inline void UserStats::set_idlesecs(::google::protobuf::uint32 value) {
  set_has_idlesecs();
  idlesecs_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.idlesecs)
}

// optional bool strong_certificate = 18 [default = false];
inline bool UserStats::has_strong_certificate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UserStats::set_has_strong_certificate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UserStats::clear_has_strong_certificate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UserStats::clear_strong_certificate() {
  strong_certificate_ = false;
  clear_has_strong_certificate();
}
inline bool UserStats::strong_certificate() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.strong_certificate)
  return strong_certificate_;
}
inline void UserStats::set_strong_certificate(bool value) {
  set_has_strong_certificate();
  strong_certificate_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.strong_certificate)
}

// optional bool opus = 19 [default = false];
inline bool UserStats::has_opus() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UserStats::set_has_opus() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UserStats::clear_has_opus() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UserStats::clear_opus() {
  opus_ = false;
  clear_has_opus();
}
inline bool UserStats::opus() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.opus)
  return opus_;
}
inline void UserStats::set_opus(bool value) {
  set_has_opus();
  opus_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.opus)
}

// -------------------------------------------------------------------

// RequestBlob

// repeated uint32 session_texture = 1;
inline int RequestBlob::session_texture_size() const {
  return session_texture_.size();
}
inline void RequestBlob::clear_session_texture() {
  session_texture_.Clear();
}
inline ::google::protobuf::uint32 RequestBlob::session_texture(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.session_texture)
  return session_texture_.Get(index);
}
inline void RequestBlob::set_session_texture(int index, ::google::protobuf::uint32 value) {
  session_texture_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.session_texture)
}
inline void RequestBlob::add_session_texture(::google::protobuf::uint32 value) {
  session_texture_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.session_texture)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestBlob::session_texture() const {
  // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.session_texture)
  return session_texture_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestBlob::mutable_session_texture() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.session_texture)
  return &session_texture_;
}

// repeated uint32 session_comment = 2;
inline int RequestBlob::session_comment_size() const {
  return session_comment_.size();
}
inline void RequestBlob::clear_session_comment() {
  session_comment_.Clear();
}
inline ::google::protobuf::uint32 RequestBlob::session_comment(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.session_comment)
  return session_comment_.Get(index);
}
inline void RequestBlob::set_session_comment(int index, ::google::protobuf::uint32 value) {
  session_comment_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.session_comment)
}
inline void RequestBlob::add_session_comment(::google::protobuf::uint32 value) {
  session_comment_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.session_comment)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestBlob::session_comment() const {
  // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.session_comment)
  return session_comment_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestBlob::mutable_session_comment() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.session_comment)
  return &session_comment_;
}

// repeated uint32 channel_description = 3;
inline int RequestBlob::channel_description_size() const {
  return channel_description_.size();
}
inline void RequestBlob::clear_channel_description() {
  channel_description_.Clear();
}
inline ::google::protobuf::uint32 RequestBlob::channel_description(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.channel_description)
  return channel_description_.Get(index);
}
inline void RequestBlob::set_channel_description(int index, ::google::protobuf::uint32 value) {
  channel_description_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.channel_description)
}
inline void RequestBlob::add_channel_description(::google::protobuf::uint32 value) {
  channel_description_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.channel_description)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestBlob::channel_description() const {
  // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.channel_description)
  return channel_description_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestBlob::mutable_channel_description() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.channel_description)
  return &channel_description_;
}

// -------------------------------------------------------------------

// ServerConfig

// optional uint32 max_bandwidth = 1;
inline bool ServerConfig::has_max_bandwidth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerConfig::set_has_max_bandwidth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerConfig::clear_has_max_bandwidth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerConfig::clear_max_bandwidth() {
  max_bandwidth_ = 0u;
  clear_has_max_bandwidth();
}
inline ::google::protobuf::uint32 ServerConfig::max_bandwidth() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.max_bandwidth)
  return max_bandwidth_;
}
inline void ServerConfig::set_max_bandwidth(::google::protobuf::uint32 value) {
  set_has_max_bandwidth();
  max_bandwidth_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.max_bandwidth)
}

// optional string welcome_text = 2;
inline bool ServerConfig::has_welcome_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerConfig::set_has_welcome_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerConfig::clear_has_welcome_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerConfig::clear_welcome_text() {
  welcome_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_welcome_text();
}
inline const ::std::string& ServerConfig::welcome_text() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.welcome_text)
  return welcome_text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerConfig::set_welcome_text(const ::std::string& value) {
  set_has_welcome_text();
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.welcome_text)
}
inline void ServerConfig::set_welcome_text(const char* value) {
  set_has_welcome_text();
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ServerConfig.welcome_text)
}
inline void ServerConfig::set_welcome_text(const char* value, size_t size) {
  set_has_welcome_text();
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ServerConfig.welcome_text)
}
inline ::std::string* ServerConfig::mutable_welcome_text() {
  set_has_welcome_text();
  // @@protoc_insertion_point(field_mutable:MumbleProto.ServerConfig.welcome_text)
  return welcome_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerConfig::release_welcome_text() {
  clear_has_welcome_text();
  return welcome_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerConfig::set_allocated_welcome_text(::std::string* welcome_text) {
  if (welcome_text != NULL) {
    set_has_welcome_text();
  } else {
    clear_has_welcome_text();
  }
  welcome_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), welcome_text);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ServerConfig.welcome_text)
}

// optional bool allow_html = 3;
inline bool ServerConfig::has_allow_html() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerConfig::set_has_allow_html() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerConfig::clear_has_allow_html() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerConfig::clear_allow_html() {
  allow_html_ = false;
  clear_has_allow_html();
}
inline bool ServerConfig::allow_html() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.allow_html)
  return allow_html_;
}
inline void ServerConfig::set_allow_html(bool value) {
  set_has_allow_html();
  allow_html_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.allow_html)
}

// optional uint32 message_length = 4;
inline bool ServerConfig::has_message_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerConfig::set_has_message_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerConfig::clear_has_message_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerConfig::clear_message_length() {
  message_length_ = 0u;
  clear_has_message_length();
}
inline ::google::protobuf::uint32 ServerConfig::message_length() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.message_length)
  return message_length_;
}
inline void ServerConfig::set_message_length(::google::protobuf::uint32 value) {
  set_has_message_length();
  message_length_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.message_length)
}

// optional uint32 image_message_length = 5;
inline bool ServerConfig::has_image_message_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerConfig::set_has_image_message_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerConfig::clear_has_image_message_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerConfig::clear_image_message_length() {
  image_message_length_ = 0u;
  clear_has_image_message_length();
}
inline ::google::protobuf::uint32 ServerConfig::image_message_length() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.image_message_length)
  return image_message_length_;
}
inline void ServerConfig::set_image_message_length(::google::protobuf::uint32 value) {
  set_has_image_message_length();
  image_message_length_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.image_message_length)
}

// -------------------------------------------------------------------

// SuggestConfig

// optional uint32 version = 1;
inline bool SuggestConfig::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuggestConfig::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SuggestConfig::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SuggestConfig::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 SuggestConfig::version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.version)
  return version_;
}
inline void SuggestConfig::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.version)
}

// optional bool positional = 2;
inline bool SuggestConfig::has_positional() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuggestConfig::set_has_positional() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SuggestConfig::clear_has_positional() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SuggestConfig::clear_positional() {
  positional_ = false;
  clear_has_positional();
}
inline bool SuggestConfig::positional() const {
  // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.positional)
  return positional_;
}
inline void SuggestConfig::set_positional(bool value) {
  set_has_positional();
  positional_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.positional)
}

// optional bool push_to_talk = 3;
inline bool SuggestConfig::has_push_to_talk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SuggestConfig::set_has_push_to_talk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SuggestConfig::clear_has_push_to_talk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SuggestConfig::clear_push_to_talk() {
  push_to_talk_ = false;
  clear_has_push_to_talk();
}
inline bool SuggestConfig::push_to_talk() const {
  // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.push_to_talk)
  return push_to_talk_;
}
inline void SuggestConfig::set_push_to_talk(bool value) {
  set_has_push_to_talk();
  push_to_talk_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.push_to_talk)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MumbleProto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mumble_2eproto__INCLUDED
